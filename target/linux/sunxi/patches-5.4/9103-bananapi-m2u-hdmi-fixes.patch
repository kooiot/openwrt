--- a/drivers/gpu/drm/sun4i/sun4i_drv.c
+++ b/drivers/gpu/drm/sun4i/sun4i_drv.c
@@ -89,6 +89,8 @@
 	struct sun4i_drv *drv;
 	int ret;
 
+	dev_info(dev, "%s: start...\n", __func__);
+
 	drm = drm_dev_alloc(&sun4i_drv_driver, dev);
 	if (IS_ERR(drm))
 		return PTR_ERR(drm);
@@ -177,6 +179,12 @@
 	return of_device_is_compatible(node, "hdmi-connector");
 }
 
+static bool sun4i_drv_node_is_mipi_dsi(struct device_node *node)
+{
+	return of_device_is_compatible(node, "allwinner,sun8i-r40-mipi-dsi") ||
+		of_device_is_compatible(node, "allwinner,sun6i-a31-mipi-dsi");
+}
+
 static bool sun4i_drv_node_is_frontend(struct device_node *node)
 {
 	return of_device_is_compatible(node, "allwinner,sun4i-a10-display-frontend") ||
@@ -270,14 +278,14 @@
 
 	port = of_graph_get_port_by_id(node, port_id);
 	if (!port) {
-		DRM_DEBUG_DRIVER("No output to bind on port %d\n", port_id);
+		DRM_DEBUG_DRIVER("No output to bind on port %d node: %pOF\n", port_id, node);
 		return;
 	}
 
 	for_each_available_child_of_node(port, ep) {
 		remote = of_graph_get_remote_port_parent(ep);
 		if (!remote) {
-			DRM_DEBUG_DRIVER("Error retrieving the output node\n");
+			DRM_DEBUG_DRIVER("Error retrieving the output node: %pOF\n", ep);
 			continue;
 		}
 
@@ -289,7 +297,7 @@
 			 * between TCON TOP and TCON.
 			 */
 			if (sun4i_drv_node_is_tcon_top(remote)) {
-				DRM_DEBUG_DRIVER("TCON output endpoint is TCON TOP... skipping\n");
+				DRM_DEBUG_DRIVER("TCON output endpoint is TCON TOP... skipping node: %pOF remote: %pOF\n", node, remote);
 				of_node_put(remote);
 				continue;
 			}
@@ -316,6 +324,7 @@
 			}
 		}
 
+		DRM_DEBUG_DRIVER("Put into FIFO node: %pOF\n", remote);
 		kfifo_put(&list->fifo, remote);
 	}
 }
@@ -327,6 +336,8 @@
 {
 	int count = 0;
 
+	dev_info(dev, "%s: node: %pOF\n", __func__, node);
+
 	/*
 	 * The frontend has been disabled in some of our old device
 	 * trees. If we find a node that is the frontend and is
@@ -346,6 +357,12 @@
 		return 0;
 
 	/*
+	 * MIPI-DSI will be the last nodes in our pipeline
+	 */
+	if (sun4i_drv_node_is_mipi_dsi(node))
+		return 0;
+
+	/*
 	 * If the device is either just a regular device, or an
 	 * enabled frontend supported by the driver, we add it to our
 	 * component list.
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c
@@ -963,9 +963,11 @@
 {
 	struct sunxi_engine *engine;
 
-	list_for_each_entry(engine, &drv->engine_list, list)
+	list_for_each_entry(engine, &drv->engine_list, list) {
+		pr_info("%s: node: %pOF engine->id: %d, id: %d\n", __func__, engine->node, engine->id, id);
 		if (engine->id == id)
 			return engine;
+	}
 
 	return ERR_PTR(-EINVAL);
 }
@@ -1063,14 +1065,21 @@
 		 * TCON TOP, remaining 2 TCONs can't be connected to anything
 		 * anyway.
 		 */
-		if (sun4i_tcon_connected_to_tcon_top(node))
-			id = sun4i_tcon_get_index(drv);
-		else
+		if (sun4i_tcon_connected_to_tcon_top(node)) {
+			pr_info("%s: sun4i_tcon_connected_to_tcon_top node:%pOF \n", __func__, node);
+			id = sun4i_tcon_get_index(drv) - 1;
+			//id = sun4i_tcon_get_index(drv);
+		} else {
+			pr_info("%s: not sun4i_tcon_connected_to_tcon_top node:%pOF \n", __func__, node);
 			id = sun4i_tcon_of_get_id_from_port(port);
+		}
 
+		pr_info("%s: sun4i_tcon_get_engine_by_id node:%pOF id:%d\n", __func__, node, id);
 		/* Get our engine by matching our ID */
 		engine = sun4i_tcon_get_engine_by_id(drv, id);
 
+		pr_info("%s: sun4i_tcon_get_engine_by_id engine:%ld\n", __func__, (long)engine);
+
 		of_node_put(port);
 		return engine;
 	}
@@ -1296,6 +1305,7 @@
 	struct drm_panel *panel;
 	int ret;
 
+	pr_info("%s: start\n", __func__);
 	quirks = of_device_get_match_data(&pdev->dev);
 
 	/* panels and bridges are present only on TCONs with channel 0 */
@@ -1305,6 +1315,8 @@
 			return ret;
 	}
 
+	pr_info("%s: add to component %pOF\n", __func__, node);
+
 	return component_add(&pdev->dev, &sun4i_tcon_ops);
 }
 
@@ -1388,6 +1400,8 @@
 	struct platform_device *pdev;
 	int id, ret;
 
+	pr_info("%s: tcon_tv set mux\n", __func__);
+
 	/* find TCON TOP platform device and TCON id */
 
 	port = of_graph_get_port_by_id(tcon->dev->of_node, 0);
@@ -1406,6 +1420,8 @@
 	if (!pdev)
 		return -EINVAL;
 
+	pr_info("%s: port: %pOF id: %d remote: %pOF\n", __func__, port, id, remote);
+
 	if (IS_ENABLED(CONFIG_DRM_SUN8I_TCON_TOP) &&
 	    encoder->encoder_type == DRM_MODE_ENCODER_TMDS) {
 		ret = sun8i_tcon_top_set_hdmi_src(&pdev->dev, id);
--- a/drivers/gpu/drm/sun4i/sun8i_dw_hdmi.c
+++ b/drivers/gpu/drm/sun4i/sun8i_dw_hdmi.c
@@ -132,6 +132,8 @@
 	struct sun8i_dw_hdmi *hdmi;
 	int ret;
 
+	pr_info("%s: SUN8I DW HDMI start...\n", __func__);
+
 	if (!pdev->dev.of_node)
 		return -ENODEV;
 
@@ -241,6 +243,8 @@
 		goto cleanup_encoder;
 	}
 
+	pr_info("%s: SUN8I DW HDMI end...\n", __func__);
+
 	return 0;
 
 cleanup_encoder:
@@ -283,11 +287,13 @@
 
 static int sun8i_dw_hdmi_probe(struct platform_device *pdev)
 {
+	pr_info("%s: SUN8I DW HDMI probe add to componet...\n", __func__);
 	return component_add(&pdev->dev, &sun8i_dw_hdmi_ops);
 }
 
 static int sun8i_dw_hdmi_remove(struct platform_device *pdev)
 {
+	pr_info("%s: SUN8I DW HDMI probe remove from componet...\n", __func__);
 	component_del(&pdev->dev, &sun8i_dw_hdmi_ops);
 
 	return 0;
--- a/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
+++ b/drivers/gpu/drm/sun4i/sun8i_hdmi_phy.c
@@ -134,6 +134,7 @@
 				      struct sun8i_hdmi_phy *phy,
 				      unsigned int clk_rate)
 {
+	pr_info("%s: hdmi: %ld clk_rate: %d\n", (long)hdmi, clk_rate);
 	regmap_update_bits(phy->regs, SUN8I_HDMI_PHY_REXT_CTRL_REG,
 			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN,
 			   SUN8I_HDMI_PHY_REXT_CTRL_REXT_EN);
@@ -560,9 +561,9 @@
 	.has_phy_clk = true,
 	.has_second_pll = true,
 	.is_custom_phy = true,
-	.phy_init = &sun8i_hdmi_phy_init_h3,
-	.phy_disable = &sun8i_hdmi_phy_disable_h3,
-	.phy_config = &sun8i_hdmi_phy_config_h3,
+	.phy_init = &sun8i_hdmi_phy_init_a83t,
+	.phy_disable = &sun8i_hdmi_phy_disable_a83t,
+	.phy_config = &sun8i_hdmi_phy_config_a83t,
 };
 
 static const struct sun8i_hdmi_phy_variant sun50i_a64_hdmi_phy = {
--- a/arch/arm/boot/dts/sun8i-r40.dtsi
+++ b/arch/arm/boot/dts/sun8i-r40.dtsi
@@ -54,6 +54,61 @@
 	#size-cells = <1>;
 	interrupt-parent = <&gic>;
 
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		/* global autoconfigured region for contiguous allocations */
+		/* linux,cma {
+			compatible = "shared-dma-pool";
+			no-map;
+			reusable;
+			size = <0x10000000>; // 256M
+			alignment = <0x4000>;
+			linux,cma-default;
+		}; */
+
+		display_reserved: framebuffer@78000000 {
+			no-map;
+			reg = <0x78000000 (1920 * 1080 * 2)>;
+		};
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		simplefb_lcd: framebuffer-lcd {
+			compatible = "allwinner,simple-framebuffer",
+				     "simple-framebuffer";
+			allwinner,pipeline = "mixer0-lcd0";
+			clocks = <&ccu CLK_TCON_LCD0>,
+				 <&display_clocks CLK_MIXER0>;
+			status = "disabled";
+		};
+
+		simplefb_hdmi: framebuffer-hdmi@78000000 {
+			compatible = "allwinner,simple-framebuffer",
+				     "simple-framebuffer";
+			allwinner,pipeline = "mixer1-tcon_top-tcon_tv0-tcon_top-hdmi";
+			clocks = <&display_clocks CLK_MIXER1>,
+				 <&ccu CLK_TCON_TV1>,
+				 <&ccu CLK_TVE1>,
+				 <&ccu CLK_TCON_TOP_TV1>,
+				 <&ccu CLK_HDMI>;
+			status = "disabled";
+			reg = <0x78000000 (1920 * 1080 * 2)>;
+			//memory-region = <&display_reserved>;
+			width = <1920>;
+			height = <1080>;
+			stride = <(1080 * 2)>;
+			format = "r5g6b5";
+			display = <&hdmi>;
+		};
+	};
+
 	clocks {
 		#address-cells = <1>;
 		#size-cells = <1>;
@@ -1250,7 +1305,7 @@
 
 		dsi: dsi@1ca0000 {
 			compatible = "allwinner,sun8i-r40-mipi-dsi",
-				     "allwinner,sun50i-a64-mipi-dsi";
+				     "allwinner,sun6i-a31-mipi-dsi";
 			reg = <0x01ca0000 0x1000>;
 			interrupts = <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&ccu CLK_BUS_MIPI_DSI>;
@@ -1317,7 +1372,7 @@
 			compatible = "allwinner,sun8i-r40-hdmi-phy";
 			reg = <0x01ef0000 0x10000>;
 			clocks = <&ccu CLK_BUS_HDMI1>, <&ccu CLK_HDMI_SLOW>,
-				 <&ccu 7>, <&ccu 16>;
+				 <&ccu CLK_PLL_VIDEO0>, <&ccu CLK_PLL_VIDEO1>;
 			clock-names = "bus", "mod", "pll-0", "pll-1";
 			resets = <&ccu RST_BUS_HDMI0>;
 			reset-names = "phy";
--- a/arch/arm/boot/dts/sun8i-r40-bananapi-m2-ultra.dts
+++ b/arch/arm/boot/dts/sun8i-r40-bananapi-m2-ultra.dts
@@ -52,6 +52,7 @@
 	compatible = "sinovoip,bpi-m2-ultra", "allwinner,sun8i-r40";
 
 	aliases {
+		display0 = &hdmi;
 		ethernet0 = &gmac;
 		serial0 = &uart0;
 		mmc0 = &mmc0;
@@ -209,7 +210,13 @@
 	};
 };
 
+&simplefb_hdmi {
+	vcc-hdmi-supply = <&reg_dcdc1>;
+	status = "okay";
+};
+
 &hdmi {
+	hvcc-supply = <&reg_dcdc1>;
 	status = "okay";
 };
 
@@ -219,6 +226,18 @@
 	};
 };
 
+&tcon_lcd0 {
+	status = "okay";
+};
+
+&tcon_tv0 {
+	status = "okay";
+};
+
+&tcon_tv1 {
+	status = "okay";
+};
+
 &i2c0 {
 	status = "okay";
 
@@ -377,14 +396,6 @@
 	regulator-name = "vdd1v2-sata";
 };
 
-&tcon_lcd0 {
-	status = "okay";
-};
-
-&tcon_tv0 {
-	status = "okay";
-};
-
 &uart0 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&uart0_pb_pins>;
