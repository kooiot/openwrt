--- a/include/linux/motorcomm_phy.h
+++ b/include/linux/motorcomm_phy.h
@@ -29,6 +29,8 @@
 #define PHY_ID_YT8618		0x0000e889
 
 #define REG_PHY_SPEC_STATUS		0x11
+#define REG_INT_MASK			0x12
+#define REG_INT_STATUS			0x13
 #define REG_DEBUG_ADDR_OFFSET		0x1e
 #define REG_DEBUG_DATA			0x1f
 
--- a/drivers/net/phy/motorcomm.c
+++ b/drivers/net/phy/motorcomm.c
@@ -622,6 +622,8 @@
 
 static int yt8521_config_init(struct phy_device *phydev)
 {
+	struct device *dev = &phydev->mdio.dev;
+	struct device_node *of_node = dev->of_node;
 	int ret;
 	int val;
 
@@ -660,6 +662,53 @@
 	if (ret < 0)
 		return ret;
 
+	if (of_property_read_bool(of_node, "nanopi,yt8521s-hack")) { 
+		/* output SyncE clock (125mhz) even link is down */
+		ret = ytphy_write_ext(phydev, 0xa012, 0x38);
+		if (ret < 0)
+			return ret;
+
+		/* disable rgmii clk 2ns delay */
+		val = ytphy_read_ext(phydev, 0xa001);
+		if (val < 0)
+			return val;
+
+		val &= ~(1 << 8);
+		ret = ytphy_write_ext(phydev, 0xa001, val);
+		if (ret < 0)
+			return ret;
+
+		/* setup delay */
+		val = (1 << 10) | (0xf << 4) | 5;
+		ret = ytphy_write_ext(phydev, 0xa003, val);
+		if (ret < 0)
+			return ret;
+
+		/* LED0: Unused/Off, LED1: Link, LED2: Activity, 8Hz */
+		ytphy_write_ext(phydev, 0xa00b, 0xe004);
+		ytphy_write_ext(phydev, 0xa00c, 0);
+		ytphy_write_ext(phydev, 0xa00d, 0x2600);
+		ytphy_write_ext(phydev, 0xa00e, 0x0070);
+		ytphy_write_ext(phydev, 0xa00f, 0x000a);
+	}
+
+	if (!of_property_read_u32(of_node, "motorcomm,led0", &val)) {
+		phydev_info(phydev, "led0 config val: %x of_node:%pOF", (u16)val, of_node);
+		ytphy_write_ext(phydev, 0xa00c, (u16)val);
+	}
+	if (!of_property_read_u32(of_node, "motorcomm,led1", &val)) {
+		phydev_info(phydev, "led1 config val: %x of_node:%pOF", (u16)val, of_node);
+		ytphy_write_ext(phydev, 0xa00d, (u16)val);
+	}
+	if (!of_property_read_u32(of_node, "motorcomm,led2", &val)) {
+		phydev_info(phydev, "led2 config val: %x of_node:%pOF", (u16)val, of_node);
+		ytphy_write_ext(phydev, 0xa00e, (u16)val);
+	}
+	if (!of_property_read_u32(of_node, "motorcomm,blink", &val)) {
+		phydev_info(phydev, "led blink config val: %x of_node:%pOF", (u16)val, of_node);
+		ytphy_write_ext(phydev, 0xa00f, (u16)val);
+	}
+
 	printk (KERN_INFO "yt8521_config_init, 8521 init call out.\n");
 	return ret;
 }
@@ -893,6 +942,32 @@
 	return 0;
 }
 
+static int yt8521_config_intr(struct phy_device *phydev)
+{
+	int val;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+		val = BIT(14) | BIT(13) | BIT(11) | BIT(10);
+	else
+		val = 0;
+
+	return phy_write(phydev, REG_INT_MASK, val);
+}
+
+static irqreturn_t yt8521_ack_interrupt(struct phy_device *phydev)
+{
+	int val;
+
+	val = phy_read(phydev, REG_INT_STATUS);
+	phydev_dbg(phydev, "intr status 0x04%x\n", val);
+	if (val < 0) {
+		phy_error(phydev);
+		return IRQ_NONE;
+	}
+
+	phy_trigger_machine(phydev);
+	return IRQ_HANDLED;
+}
 
 #if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
 #else
@@ -1374,6 +1449,8 @@
         .read_status    = yt8521_read_status,
         .suspend        = yt8521_suspend,
         .resume         = yt8521_resume,
+		.handle_interrupt = yt8521_ack_interrupt,
+		.config_intr	= yt8521_config_intr,
 #if (YTPHY_ENABLE_WOL)
 		.get_wol		= &ytphy_get_wol,
 		.set_wol		= &ytphy_set_wol,
