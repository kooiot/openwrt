--- a/include/linux/motorcomm_phy.h
+++ b/include/linux/motorcomm_phy.h
@@ -29,6 +29,8 @@
 #define PHY_ID_YT8618		0x0000e889
 
 #define REG_PHY_SPEC_STATUS		0x11
+#define REG_INT_MASK			0x12
+#define REG_INT_STATUS			0x13
 #define REG_DEBUG_ADDR_OFFSET		0x1e
 #define REG_DEBUG_DATA			0x1f
 
--- a/drivers/net/phy/motorcomm.c
+++ b/drivers/net/phy/motorcomm.c
@@ -185,6 +185,8 @@
 
 static int yt8512_led_init(struct phy_device *phydev)
 {
+	struct device *dev = &phydev->mdio.dev;
+	struct device_node *of_node = dev->of_node;
 	int ret;
 	int val;
 	int mask;
@@ -215,6 +217,24 @@
 
 	ret = ytphy_write_ext(phydev, YT8512_LED1_BT_ON_EN, val);
 
+	if (of_property_read_u32(of_node, "motorcomm,led0", &val)) {
+		phydev_info(phydev, "write led0 config val: %x", val);
+		ret = ytphy_write_ext(phydev, YT8512_EXTREG_LED0, val);
+		if (ret < 0) {
+			phydev_err(phydev, "write led0 config failed!\n");
+			return ret;
+		}
+	}
+
+	if (of_property_read_u32(of_node, "motorcomm,led1", &val)) {
+		phydev_info(phydev, "write led1 config val: %x", val);
+		ret = ytphy_write_ext(phydev, YT8512_EXTREG_LED1, val);
+		if (ret < 0) {
+			phydev_err(phydev, "write led1 config failed!\n");
+			return ret;
+		}
+	}
+
 	return ret;
 }
 
@@ -230,6 +250,30 @@
 	if (ret < 0)
 		return ret;
 
+	// Try to read phy_id if failed, then not initialize it
+	ret = phy_read(phydev, MII_PHYSID1) << 16;
+	ret |= phy_read(phydev, MII_PHYSID2);
+	phydev_info(phydev, "%s: phy_id: %x", __func__, ret);
+	if (ret == 0)
+		return 0;
+
+	// 10BT bug?
+	ret = ytphy_read_ext(phydev, 0x200a /*YT8512_10BT_BUG_REG*/);
+	if (ret < 0) {
+		phydev_err(phydev, "read 10BT BUG REG failed!\n");
+		return ret;
+	} else {
+		phydev_info(phydev, "10BT BUG REG val: %x", ret);
+	}
+
+	if (0) {
+		ret = ytphy_write_ext(phydev, 0x200a /*YT8512_10BT_BUG_REG*/, ret & 0xFBFF);
+		if (ret < 0) {
+			phydev_err(phydev, "write 10BT BUG REG failed!\n");
+			return ret;
+		}
+	}
+
 	ret = yt8512_clk_init(phydev);
 	if (ret < 0)
 		return ret;
@@ -622,6 +666,8 @@
 
 static int yt8521_config_init(struct phy_device *phydev)
 {
+	struct device *dev = &phydev->mdio.dev;
+	struct device_node *of_node = dev->of_node;
 	int ret;
 	int val;
 
@@ -660,6 +706,67 @@
 	if (ret < 0)
 		return ret;
 
+	if (of_property_read_bool(of_node, "tlink,yt8521s-hack")) {
+		ret = ytphy_write_ext(phydev, 0xa003 /*YT8521_RGMII_CFG_REG*/, 0xf);
+		if (ret < 0) {
+			phydev_err(phydev, "write RGMII Config failed!\n");
+			return ret;
+		}
+
+		ret = phy_write(phydev, MII_BMCR, 0x9040); // ???
+		if (ret < 0) {
+			phydev_err(phydev, "write MII_BMCR failed!\n");
+			return ret;
+		}
+	}
+
+	if (of_property_read_bool(of_node, "nanopi,yt8521s-hack")) {
+		/* output SyncE clock (125mhz) even link is down */
+		ret = ytphy_write_ext(phydev, 0xa012, 0x38);
+		if (ret < 0)
+			return ret;
+
+		/* disable rgmii clk 2ns delay */
+		val = ytphy_read_ext(phydev, 0xa001);
+		if (val < 0)
+			return val;
+
+		val &= ~(1 << 8);
+		ret = ytphy_write_ext(phydev, 0xa001, val);
+		if (ret < 0)
+			return ret;
+
+		/* setup delay */
+		val = (1 << 10) | (0xf << 4) | 5;
+		ret = ytphy_write_ext(phydev, 0xa003, val);
+		if (ret < 0)
+			return ret;
+
+		/* LED0: Unused/Off, LED1: Link, LED2: Activity, 8Hz */
+		ytphy_write_ext(phydev, 0xa00b, 0xe004);
+		ytphy_write_ext(phydev, 0xa00c, 0);
+		ytphy_write_ext(phydev, 0xa00d, 0x2600);
+		ytphy_write_ext(phydev, 0xa00e, 0x0070);
+		ytphy_write_ext(phydev, 0xa00f, 0x000a);
+	}
+
+	if (!of_property_read_u32(of_node, "motorcomm,led0", &val)) {
+		phydev_info(phydev, "led0 config val: %x of_node:%pOF", (u16)val, of_node);
+		ytphy_write_ext(phydev, 0xa00c, (u16)val);
+	}
+	if (!of_property_read_u32(of_node, "motorcomm,led1", &val)) {
+		phydev_info(phydev, "led1 config val: %x of_node:%pOF", (u16)val, of_node);
+		ytphy_write_ext(phydev, 0xa00d, (u16)val);
+	}
+	if (!of_property_read_u32(of_node, "motorcomm,led2", &val)) {
+		phydev_info(phydev, "led2 config val: %x of_node:%pOF", (u16)val, of_node);
+		ytphy_write_ext(phydev, 0xa00e, (u16)val);
+	}
+	if (!of_property_read_u32(of_node, "motorcomm,blink", &val)) {
+		phydev_info(phydev, "led blink config val: %x of_node:%pOF", (u16)val, of_node);
+		ytphy_write_ext(phydev, 0xa00f, (u16)val);
+	}
+
 	printk (KERN_INFO "yt8521_config_init, 8521 init call out.\n");
 	return ret;
 }
@@ -893,6 +1000,32 @@
 	return 0;
 }
 
+static int yt8521_config_intr(struct phy_device *phydev)
+{
+	int val;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+		val = BIT(14) | BIT(13) | BIT(11) | BIT(10);
+	else
+		val = 0;
+
+	return phy_write(phydev, REG_INT_MASK, val);
+}
+
+static irqreturn_t yt8521_ack_interrupt(struct phy_device *phydev)
+{
+	int val;
+
+	val = phy_read(phydev, REG_INT_STATUS);
+	phydev_dbg(phydev, "intr status 0x04%x\n", val);
+	if (val < 0) {
+		phy_error(phydev);
+		return IRQ_NONE;
+	}
+
+	phy_trigger_machine(phydev);
+	return IRQ_HANDLED;
+}
 
 #if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
 #else
@@ -1345,8 +1478,8 @@
 		.phy_id		= PHY_ID_YT8512B,
 		.name		= "YT8512B Ethernet",
 		.phy_id_mask	= MOTORCOMM_PHY_ID_MASK,
-#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
 		.features	= PHY_BASIC_FEATURES,
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0) )
 		.flags			= PHY_HAS_INTERRUPT,
 #endif		
 		.config_aneg	= genphy_config_aneg,
@@ -1374,6 +1507,8 @@
         .read_status    = yt8521_read_status,
         .suspend        = yt8521_suspend,
         .resume         = yt8521_resume,
+		.handle_interrupt = yt8521_ack_interrupt,
+		.config_intr	= yt8521_config_intr,
 #if (YTPHY_ENABLE_WOL)
 		.get_wol		= &ytphy_get_wol,
 		.set_wol		= &ytphy_set_wol,
