From 86c0dbbde32df275b08ef3f50d8be2bdfb26f610 Mon Sep 17 00:00:00 2001
From: Jayantajit Gogoi <jayanta.gogoi525@gmail.com>
Date: Wed, 10 Jun 2020 09:50:16 +0000
Subject: [PATCH 1/1] rock pi e

---
 package/boot/uboot-rockchip/Makefile          |   11 +-
 .../patches/004-add_rock64_gen3_support.patch |   84 -
 .../patches/009-add-rock-pi-e-dts.patch       |  325 +++
 .../patches/010-add-rock-pi-e-defconfig.patch |  110 +
 .../patches/general-prioritize-sd.patch       |   15 +
 .../armv8/base-files/etc/board.d/02_network   |    3 +
 target/linux/rockchip/config-default          |   18 +
 target/linux/rockchip/image/armv8.mk          |    9 +
 .../0001-rock64_misc_power_fixes.patch        |  133 --
 .../patches-5.4/0003-usb3_fixes.patch         |  126 --
 .../0005-fix_TX_checksumm_offload.patch       |   57 -
 .../0006-rk3328_add_sdmmc_ext_node.patch      |   34 -
 .../0007-rk3328_add_mmc_reset.patch           |   40 -
 .../patches-5.4/0010-mmc_rename.patch         |   56 -
 ...0011-rock64_add_spi_flash_partitions.patch |   39 -
 .../0012-add_sound_rk3328_rock64.patch        |  170 --
 .../RK3328-enable-1512mhz-opp.patch           |   16 +
 .../patches-5.4/add-radxa-rock-pi-e.patch     |  492 +++++
 .../add-rk3328-usb3-phy-driver.patch          | 1504 ++++++++++++++
 .../patches-5.4/rk3328-add-dmc-driver.patch   | 1796 +++++++++++++++++
 20 files changed, 4298 insertions(+), 740 deletions(-)
 delete mode 100644 package/boot/uboot-rockchip/patches/004-add_rock64_gen3_support.patch
 create mode 100644 package/boot/uboot-rockchip/patches/009-add-rock-pi-e-dts.patch
 create mode 100644 package/boot/uboot-rockchip/patches/010-add-rock-pi-e-defconfig.patch
 create mode 100644 package/boot/uboot-rockchip/patches/general-prioritize-sd.patch
 delete mode 100644 target/linux/rockchip/patches-5.4/0001-rock64_misc_power_fixes.patch
 delete mode 100644 target/linux/rockchip/patches-5.4/0003-usb3_fixes.patch
 delete mode 100644 target/linux/rockchip/patches-5.4/0005-fix_TX_checksumm_offload.patch
 delete mode 100644 target/linux/rockchip/patches-5.4/0006-rk3328_add_sdmmc_ext_node.patch
 delete mode 100644 target/linux/rockchip/patches-5.4/0007-rk3328_add_mmc_reset.patch
 delete mode 100644 target/linux/rockchip/patches-5.4/0010-mmc_rename.patch
 delete mode 100644 target/linux/rockchip/patches-5.4/0011-rock64_add_spi_flash_partitions.patch
 delete mode 100644 target/linux/rockchip/patches-5.4/0012-add_sound_rk3328_rock64.patch
 create mode 100644 target/linux/rockchip/patches-5.4/RK3328-enable-1512mhz-opp.patch
 create mode 100644 target/linux/rockchip/patches-5.4/add-radxa-rock-pi-e.patch
 create mode 100644 target/linux/rockchip/patches-5.4/add-rk3328-usb3-phy-driver.patch
 create mode 100644 target/linux/rockchip/patches-5.4/rk3328-add-dmc-driver.patch

diff --git a/package/boot/uboot-rockchip/Makefile b/package/boot/uboot-rockchip/Makefile
index 86c3785add..ab9fce2d14 100644
--- a/package/boot/uboot-rockchip/Makefile
+++ b/package/boot/uboot-rockchip/Makefile
@@ -37,8 +37,17 @@ define U-Boot/rock64-rk3328
   BL31=$(STAGING_DIR_IMAGE)/rk3328_bl31.elf
 endef
 
+define U-Boot/rock-pi-e-rk3328
+  BUILD_SUBTARGET:=armv8
+  NAME:=Rock Pi E
+  BUILD_DEVICES:= \
+    radxa_rock-pi-e
+  BL31=$(STAGING_DIR_IMAGE)/rk3328_bl31.elf
+endef
+
 UBOOT_TARGETS := \
   rockpro64-rk3399 \
+  rock-pi-e-rk3328 \
   rock64-rk3328
 
 UBOOT_CONFIGURE_VARS += USE_PRIVATE_LIBGCC=yes
@@ -47,7 +56,7 @@ UBOOT_MAKE_FLAGS += \
   BL31=$(BL31)
 
 define Build/Configure
-	 echo CONFIG_CMD_SETEXPR=y >> $(PKG_BUILD_DIR)/configs/$(UBOOT_CONFIG)_defconfig
+	echo CONFIG_CMD_SETEXPR=y >> $(PKG_BUILD_DIR)/configs/$(UBOOT_CONFIG)_defconfig
 	$(call Build/Configure/U-Boot)
 	$(SED) 's#CONFIG_MKIMAGE_DTC_PATH=.*#CONFIG_MKIMAGE_DTC_PATH="$(PKG_BUILD_DIR)/scripts/dtc/dtc"#g' $(PKG_BUILD_DIR)/.config
 	echo 'CONFIG_IDENT_STRING=" OpenWrt"' >> $(PKG_BUILD_DIR)/.config
diff --git a/package/boot/uboot-rockchip/patches/004-add_rock64_gen3_support.patch b/package/boot/uboot-rockchip/patches/004-add_rock64_gen3_support.patch
deleted file mode 100644
index 72a61a2fb7..0000000000
--- a/package/boot/uboot-rockchip/patches/004-add_rock64_gen3_support.patch
+++ /dev/null
@@ -1,84 +0,0 @@
-Use the same approach as ROC-RK3328-CC which enables SPL GPIO,
-pinctl and regulator support. This allows the gen3 board to
-boot through SPL and does not break gen2 in the process.
-
-Signed-off-by: Kurt Miller <kurt at intricatesoftware.com>
----
-
- arch/arm/dts/rk3328-rock64-u-boot.dtsi | 21 +++++++++++++++++++++
- configs/rock64-rk3328_defconfig        |  7 ++++++-
- 2 files changed, 27 insertions(+), 1 deletion(-)
-
-diff --git a/arch/arm/dts/rk3328-rock64-u-boot.dtsi b/arch/arm/dts/rk3328-rock64-u-boot.dtsi
-index 8318bf4e60..f076075076 100644
---- a/arch/arm/dts/rk3328-rock64-u-boot.dtsi
-+++ b/arch/arm/dts/rk3328-rock64-u-boot.dtsi
-@@ -11,6 +11,28 @@
- 	};
- };
- 
-+&gpio0 {
-+	u-boot,dm-spl;
-+};
-+
-+&pinctrl {
-+	u-boot,dm-spl;
-+};
-+
-+&sdmmc0m1_gpio {
-+	u-boot,dm-spl;
-+};
-+
-+&pcfg_pull_up_4ma {
-+	u-boot,dm-spl;
-+};
-+
- &usb_host0_xhci {
-+ 	vbus-supply = <&vcc_host_5v>;
- 	status = "okay";
- };
-+
-+/* Need this and all the pinctrl/gpio stuff above to set pinmux */
-+&vcc_sd {
-+	u-boot,dm-spl;
-+};
-diff --git a/configs/rock64-rk3328_defconfig b/configs/rock64-rk3328_defconfig
-index 7d096d38c6..0bc2198f5c 100644
---- a/configs/rock64-rk3328_defconfig
-+++ b/configs/rock64-rk3328_defconfig
-@@ -1,6 +1,7 @@
- CONFIG_ARM=y
- CONFIG_ARCH_ROCKCHIP=y
- CONFIG_SYS_TEXT_BASE=0x00200000
-+CONFIG_SPL_GPIO_SUPPORT=y
- CONFIG_ENV_OFFSET=0x3F8000
- CONFIG_ROCKCHIP_RK3328=y
- CONFIG_TPL_ROCKCHIP_COMMON_BOARD=y
-@@ -25,6 +26,8 @@ CONFIG_DISPLAY_BOARDINFO_LATE=y
- # CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
- CONFIG_TPL_SYS_MALLOC_SIMPLE=y
- CONFIG_SPL_STACK_R=y
-+CONFIG_SPL_I2C_SUPPORT=y
-+CONFIG_SPL_POWER_SUPPORT=y
- CONFIG_SPL_ATF=y
- CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y
- CONFIG_CMD_BOOTZ=y
-@@ -36,7 +39,7 @@ CONFIG_CMD_TIME=y
- CONFIG_SPL_OF_CONTROL=y
- CONFIG_TPL_OF_CONTROL=y
- CONFIG_DEFAULT_DEVICE_TREE="rk3328-rock64"
--CONFIG_OF_SPL_REMOVE_PROPS="pinctrl-0 pinctrl-names clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
-+CONFIG_OF_SPL_REMOVE_PROPS="clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
- CONFIG_TPL_OF_PLATDATA=y
- CONFIG_ENV_IS_IN_MMC=y
- CONFIG_SYS_RELOC_GD_ENV_ADDR=y
-@@ -65,7 +68,9 @@ CONFIG_PINCTRL=y
- CONFIG_SPL_PINCTRL=y
- CONFIG_DM_PMIC=y
- CONFIG_PMIC_RK8XX=y
-+CONFIG_SPL_DM_REGULATOR=y
- CONFIG_REGULATOR_PWM=y
-+CONFIG_SPL_DM_REGULATOR_FIXED=y
- CONFIG_DM_REGULATOR_FIXED=y
- CONFIG_REGULATOR_RK8XX=y
- CONFIG_PWM_ROCKCHIP=y
diff --git a/package/boot/uboot-rockchip/patches/009-add-rock-pi-e-dts.patch b/package/boot/uboot-rockchip/patches/009-add-rock-pi-e-dts.patch
new file mode 100644
index 0000000000..637b1c1e50
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/009-add-rock-pi-e-dts.patch
@@ -0,0 +1,325 @@
+diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
+index c6af87cf5e..61afe94a05 100644
+--- a/arch/arm/dts/Makefile
++++ b/arch/arm/dts/Makefile
+@@ -107,6 +107,7 @@ dtb-$(CONFIG_ROCKCHIP_RK3308) += \
+ dtb-$(CONFIG_ROCKCHIP_RK3328) += \
+ 	rk3328-evb.dtb \
+-	rk3328-rock64.dtb
++	rk3328-rock64.dtb \
++	rk3328-rock-pi-e.dtb
+ 
+ dtb-$(CONFIG_ROCKCHIP_RK3368) += \
+ 	rk3368-lion.dtb \
+diff --git a/arch/arm/dts/rk3328-rock-pi-e-u-boot.dtsi b/arch/arm/dts/rk3328-rock-pi-e-u-boot.dtsi
+new file mode 100644
+index 0000000000..bf5b1f3adc
+--- /dev/null
++++ b/arch/arm/dts/rk3328-rock-pi-e-u-boot.dtsi
+@@ -0,0 +1,33 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * (C) Copyright 2020 Radxa
++ */
++
++#include "rk3328-u-boot.dtsi"
++#include "rk3328-sdram-ddr3-666.dtsi"
++
++&gpio0 {
++	u-boot,dm-spl;
++};
++
++&pinctrl {
++	u-boot,dm-spl;
++};
++
++&sdmmc0m1_gpio {
++	u-boot,dm-spl;
++};
++
++&pcfg_pull_up_4ma {
++	u-boot,dm-spl;
++};
++
++&usb_host0_xhci {
++	vbus-supply = <&vcc5v0_host_xhci>;
++	status = "okay";
++};
++
++/* Need this and all the pinctrl/gpio stuff above to set pinmux */
++&vcc_sd {
++	u-boot,dm-spl;
++};
+diff --git a/arch/arm/dts/rk3328-rock-pi-e.dts b/arch/arm/dts/rk3328-rock-pi-e.dts
+new file mode 100644
+index 0000000000..4b9f9a8248
+--- /dev/null
++++ b/arch/arm/dts/rk3328-rock-pi-e.dts
+@@ -0,0 +1,267 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * (C) Copyright 2020 Radxa
++ */
++
++/dts-v1/;
++#include "rk3328.dtsi"
++
++/ {
++	model = "Radxa Rock Pi E";
++	compatible = "radxa,rock-pi-e", "rockchip,rk3328";
++
++	chosen {
++		stdout-path = "serial2:1500000n8";
++	};
++
++	gmac_clkin: external-gmac-clock {
++		compatible = "fixed-clock";
++		clock-frequency = <125000000>;
++		clock-output-names = "gmac_clkin";
++		#clock-cells = <0>;
++	};
++
++	vcc_sd: sdmmc-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_LOW>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&sdmmc0m1_gpio>;
++		regulator-name = "vcc_sd";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		vin-supply = <&vcc_io>;
++	};
++
++	vcc5v0_host_xhci: vcc5v0-host-xhci-drv {
++		compatible = "regulator-fixed";
++		enable-active-high;
++		regulator-name = "vcc5v0_host_xhci";
++		gpio = <&gpio3 RK_PA7 GPIO_ACTIVE_HIGH>;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++
++	vcc_sys: vcc-sys {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_sys";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++};
++
++&cpu0 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu1 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu2 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu3 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&emmc {
++	bus-width = <8>;
++	cap-mmc-highspeed;
++	mmc-hs200-1_8v;
++	supports-emmc;
++	disable-wp;
++	non-removable;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
++	vmmc-supply = <&vcc_io>;
++	vqmmc-supply = <&vcc18_emmc>;
++	status = "okay";
++};
++
++&gmac2io {
++	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
++	assigned-clock-parents = <&gmac_clkin>, <&gmac_clkin>;
++	clock_in_out = "input";
++	phy-supply = <&vcc_io>;
++	phy-mode = "rgmii";
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmiim1_pins>;
++	snps,force_thresh_dma_mode;
++	snps,reset-gpio = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>;
++	snps,reset-active-low;
++	snps,reset-delays-us = <0 10000 50000>;
++	tx_delay = <0x26>;
++	rx_delay = <0x11>;
++	status = "okay";
++};
++
++&i2c1 {
++	status = "okay";
++
++	rk805: rk805@18 {
++		compatible = "rockchip,rk805";
++		status = "okay";
++		reg = <0x18>;
++		interrupt-parent = <&gpio2>;
++		interrupts = <6 IRQ_TYPE_LEVEL_LOW>;
++		#clock-cells = <1>;
++		clock-output-names = "xin32k", "rk805-clkout2";
++		pinctrl-names = "default";
++		pinctrl-0 = <&pmic_int_l>;
++		rockchip,system-power-controller;
++		wakeup-source;
++
++		vcc1-supply = <&vcc_sys>;
++		vcc2-supply = <&vcc_sys>;
++		vcc3-supply = <&vcc_sys>;
++		vcc4-supply = <&vcc_sys>;
++		vcc5-supply = <&vcc_io>;
++		vcc6-supply = <&vcc_sys>;
++
++		regulators {
++			vdd_logic: DCDC_REG1 {
++				regulator-name = "vdd_logic";
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-ramp-delay = <12500>;
++				regulator-always-on;
++				regulator-boot-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++
++			vdd_arm: DCDC_REG2 {
++	regulator-name = "vdd_arm";
++	regulator-min-microvolt = <712500>;
++	regulator-max-microvolt = <1450000>;
++	regulator-ramp-delay = <12500>;
++	regulator-always-on;
++	regulator-boot-on;
++	regulator-state-mem {
++	regulator-on-in-suspend;
++	regulator-suspend-microvolt = <950000>;
++	};
++	};
++
++	vcc_ddr: DCDC_REG3 {
++	regulator-name = "vcc_ddr";
++	regulator-always-on;
++	regulator-boot-on;
++	regulator-state-mem {
++	regulator-on-in-suspend;
++	};
++	};
++
++	vcc_io: DCDC_REG4 {
++	regulator-name = "vcc_io";
++	regulator-min-microvolt = <3300000>;
++	regulator-max-microvolt = <3300000>;
++	regulator-always-on;
++	regulator-boot-on;
++	regulator-state-mem {
++	regulator-on-in-suspend;
++	regulator-suspend-microvolt = <3300000>;
++	};
++	};
++
++	vcc_18: LDO_REG1 {
++	regulator-name = "vcc_18";
++	regulator-min-microvolt = <1800000>;
++	regulator-max-microvolt = <1800000>;
++	regulator-always-on;
++	regulator-boot-on;
++	regulator-state-mem {
++	regulator-on-in-suspend;
++	regulator-suspend-microvolt = <1800000>;
++	};
++	};
++
++	vcc18_emmc: LDO_REG2 {
++	regulator-name = "vcc18_emmc";
++	regulator-min-microvolt = <1800000>;
++	regulator-max-microvolt = <1800000>;
++	regulator-always-on;
++	regulator-boot-on;
++	regulator-state-mem {
++	regulator-on-in-suspend;
++	regulator-suspend-microvolt = <1800000>;
++	};
++	};
++
++	vdd_10: LDO_REG3 {
++	regulator-name = "vdd_10";
++	regulator-min-microvolt = <1000000>;
++	regulator-max-microvolt = <1000000>;
++	regulator-always-on;
++	regulator-boot-on;
++	regulator-state-mem {
++	regulator-on-in-suspend;
++	regulator-suspend-microvolt = <1000000>;
++	};
++	};
++	};
++	};
++};
++
++&io_domains {
++	status = "okay";
++
++	vccio1-supply = <&vcc_io>;
++	vccio2-supply = <&vcc18_emmc>;
++	vccio3-supply = <&vcc_io>;
++	vccio4-supply = <&vcc_io>;
++	vccio5-supply = <&vcc_io>;
++	vccio6-supply = <&vcc_io>;
++	pmuio-supply = <&vcc_io>;
++};
++
++&pinctrl {
++	pmic {
++	pmic_int_l: pmic-int-l {
++	rockchip,pins = <2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>;
++	};
++	};
++};
++
++&sdmmc {
++	bus-width = <4>;
++	cap-mmc-highspeed;
++	cap-sd-highspeed;
++	card-detect-delay = <200>;
++	disable-wp;
++	max-frequency = <150000000>;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_dectn &sdmmc0_bus4>;
++	supports-sd;
++	vmmc-supply = <&vcc_sd>;
++	status = "okay";
++};
++
++&saradc {
++	status = "okay";
++};
++
++&uart2 {
++	status = "okay";
++};
++
++&usb20_otg {
++	status = "okay";
++};
++
++&usb_host0_ehci {
++	status = "okay";
++};
++
++&usb_host0_ohci {
++	status = "okay";
++};
diff --git a/package/boot/uboot-rockchip/patches/010-add-rock-pi-e-defconfig.patch b/package/boot/uboot-rockchip/patches/010-add-rock-pi-e-defconfig.patch
new file mode 100644
index 0000000000..e9d99158ad
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/010-add-rock-pi-e-defconfig.patch
@@ -0,0 +1,110 @@
+diff --git a/configs/rock-pi-e-rk3328_defconfig b/configs/rock-pi-e-rk3328_defconfig
+new file mode 100644
+index 0000000000..759838775f
+--- /dev/null
++++ b/configs/rock-pi-e-rk3328_defconfig
+@@ -0,0 +1,104 @@
++CONFIG_ARM=y
++CONFIG_ARCH_ROCKCHIP=y
++CONFIG_SYS_TEXT_BASE=0x00200000
++CONFIG_SPL_GPIO_SUPPORT=y
++CONFIG_ENV_OFFSET=0x3F8000
++CONFIG_ROCKCHIP_RK3328=y
++CONFIG_TPL_ROCKCHIP_COMMON_BOARD=y
++CONFIG_TPL_LIBCOMMON_SUPPORT=y
++CONFIG_TPL_LIBGENERIC_SUPPORT=y
++CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
++CONFIG_SPL_STACK_R_ADDR=0x4000000
++CONFIG_SPL_SYS_MALLOC_F_LEN=0x4000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEBUG_UART_BASE=0xFF130000
++CONFIG_DEBUG_UART_CLOCK=24000000
++CONFIG_SMBIOS_PRODUCT_NAME="rock-pi-e_rk3328"
++CONFIG_DEBUG_UART=y
++CONFIG_TPL_SYS_MALLOC_F_LEN=0x800
++# CONFIG_ANDROID_BOOT_IMAGE is not set
++CONFIG_FIT=y
++CONFIG_FIT_VERBOSE=y
++CONFIG_SPL_LOAD_FIT=y
++CONFIG_DEFAULT_FDT_FILE="rockchip/rk3328-rock-pi-e.dtb"
++CONFIG_MISC_INIT_R=y
++# CONFIG_DISPLAY_CPUINFO is not set
++CONFIG_DISPLAY_BOARDINFO_LATE=y
++# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
++CONFIG_TPL_SYS_MALLOC_SIMPLE=y
++CONFIG_SPL_STACK_R=y
++CONFIG_SPL_I2C_SUPPORT=y
++CONFIG_SPL_POWER_SUPPORT=y
++CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN=0x10000
++CONFIG_SPL_ATF=y
++CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y
++CONFIG_TPL_DRIVERS_MISC_SUPPORT=y
++CONFIG_CMD_BOOTZ=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_TIME=y
++CONFIG_SPL_OF_CONTROL=y
++CONFIG_TPL_OF_CONTROL=y
++CONFIG_DEFAULT_DEVICE_TREE="rk3328-rock-pi-e"
++CONFIG_OF_SPL_REMOVE_PROPS="clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
++CONFIG_TPL_OF_PLATDATA=y
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_TPL_DM=y
++CONFIG_REGMAP=y
++CONFIG_SPL_REGMAP=y
++CONFIG_TPL_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_SPL_SYSCON=y
++CONFIG_TPL_SYSCON=y
++CONFIG_CLK=y
++CONFIG_SPL_CLK=y
++CONFIG_FASTBOOT_BUF_ADDR=0x800800
++CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
++CONFIG_ROCKCHIP_GPIO=y
++CONFIG_SYS_I2C_ROCKCHIP=y
++CONFIG_MMC_DW=y
++CONFIG_MMC_DW_ROCKCHIP=y
++CONFIG_SF_DEFAULT_SPEED=20000000
++CONFIG_DM_ETH=y
++CONFIG_ETH_DESIGNWARE=y
++CONFIG_GMAC_ROCKCHIP=y
++CONFIG_PHY=y
++CONFIG_PINCTRL=y
++CONFIG_SPL_PINCTRL=y
++CONFIG_DM_PMIC=y
++CONFIG_PMIC_RK8XX=y
++CONFIG_SPL_DM_REGULATOR=y
++CONFIG_REGULATOR_PWM=y
++CONFIG_SPL_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_REGULATOR_RK8XX=y
++CONFIG_PWM_ROCKCHIP=y
++CONFIG_RAM=y
++CONFIG_SPL_RAM=y
++CONFIG_TPL_RAM=y
++CONFIG_DM_RESET=y
++CONFIG_BAUDRATE=1500000
++CONFIG_DEBUG_UART_SHIFT=2
++CONFIG_DEBUG_UART_ANNOUNCE=y
++CONFIG_DEBUG_UART_SKIP_INIT=y
++CONFIG_SYSRESET=y
++# CONFIG_TPL_SYSRESET is not set
++CONFIG_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_DWC3=y
++CONFIG_USB_EHCI_HCD=y
++CONFIG_USB_EHCI_GENERIC=y
++CONFIG_USB_OHCI_HCD=y
++CONFIG_USB_OHCI_GENERIC=y
++CONFIG_USB_DWC2=y
++CONFIG_USB_DWC3=y
++# CONFIG_USB_DWC3_GADGET is not set
++CONFIG_USB_GADGET=y
++CONFIG_USB_GADGET_DWC2_OTG=y
++CONFIG_SPL_TINY_MEMSET=y
++CONFIG_TPL_TINY_MEMSET=y
++CONFIG_ERRNO_STR=y
++CONFIG_SMBIOS_MANUFACTURER="radxa"
diff --git a/package/boot/uboot-rockchip/patches/general-prioritize-sd.patch b/package/boot/uboot-rockchip/patches/general-prioritize-sd.patch
new file mode 100644
index 0000000000..b71d4a2119
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/general-prioritize-sd.patch
@@ -0,0 +1,15 @@
+diff --git a/include/configs/rockchip-common.h b/include/configs/rockchip-common.h
+index 68e1105a..906c22ed 100644
+--- a/include/configs/rockchip-common.h
++++ b/include/configs/rockchip-common.h
+@@ -14,8 +14,8 @@
+ /* First try to boot from SD (index 0), then eMMC (index 1) */
+ #if CONFIG_IS_ENABLED(CMD_MMC)
+ 	#define BOOT_TARGET_MMC(func) \
+-		func(MMC, mmc, 0) \
+-		func(MMC, mmc, 1)
++		func(MMC, mmc, 1) \
++		func(MMC, mmc, 0)
+ #else
+ 	#define BOOT_TARGET_MMC(func)
+ #endif
diff --git a/target/linux/rockchip/armv8/base-files/etc/board.d/02_network b/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
index c5adda1706..b436110f42 100755
--- a/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
+++ b/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
@@ -5,6 +5,9 @@
 board_config_update
 
 case "$(board_name)" in
+radxa,rock-pi-e)
+	ucidef_set_interfaces_lan_wan "eth1" "eth0"
+	;;
 *)
 	ucidef_set_interface_lan 'eth0'
 	;;
diff --git a/target/linux/rockchip/config-default b/target/linux/rockchip/config-default
index 1b2d5e1903..e7c8c16e14 100644
--- a/target/linux/rockchip/config-default
+++ b/target/linux/rockchip/config-default
@@ -297,3 +297,21 @@ CONFIG_UNMAP_KERNEL_AT_EL0=y
 CONFIG_VMAP_STACK=y
 CONFIG_XPS=y
 CONFIG_ZONE_DMA32=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_ROCKCHIP=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_TEST=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_ACT8865=y
+CONFIG_REGULATOR_DEBUG=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_ROCKCHIP_IODOMAIN=y
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_PHY_ROCKCHIP_PCIE=y
+CONFIG_PHY_ROCKCHIP_EMMC=y
\ No newline at end of file
diff --git a/target/linux/rockchip/image/armv8.mk b/target/linux/rockchip/image/armv8.mk
index 3f60cbc6c0..176b4e10f5 100644
--- a/target/linux/rockchip/image/armv8.mk
+++ b/target/linux/rockchip/image/armv8.mk
@@ -5,6 +5,15 @@
 # See /LICENSE for more information.
 #
 
+define Device/radxa_rock-pi-e
+  DEVICE_VENDOR := Radxa
+  DEVICE_MODEL := Rock Pi E
+  SOC := rk3328
+  UBOOT_DEVICE_NAME := rock-pi-e-rk3328
+  IMAGE/sysupgrade.img.gz := boot-common | boot-script | sdcard-img | gzip | append-metadata
+endef
+TARGET_DEVICES += radxa_rock-pi-e
+
 define Device/pine64_rock64
   DEVICE_VENDOR := Pine64
   DEVICE_MODEL := Rock64
diff --git a/target/linux/rockchip/patches-5.4/0001-rock64_misc_power_fixes.patch b/target/linux/rockchip/patches-5.4/0001-rock64_misc_power_fixes.patch
deleted file mode 100644
index daf2f3900c..0000000000
--- a/target/linux/rockchip/patches-5.4/0001-rock64_misc_power_fixes.patch
+++ /dev/null
@@ -1,133 +0,0 @@
---- a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-+++ b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-@@ -23,7 +23,7 @@
- 
- 	vcc_sd: sdmmc-regulator {
- 		compatible = "regulator-fixed";
--		gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_LOW>;
-+		gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_HIGH>;
- 		pinctrl-names = "default";
- 		pinctrl-0 = <&sdmmc0m1_gpio>;
- 		regulator-name = "vcc_sd";
-@@ -34,7 +34,7 @@
- 
- 	vcc_host_5v: vcc-host-5v-regulator {
- 		compatible = "regulator-fixed";
--		gpio = <&gpio0 RK_PA2 GPIO_ACTIVE_LOW>;
-+		gpio = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
- 		pinctrl-names = "default";
- 		pinctrl-0 = <&usb20_host_drv>;
- 		regulator-name = "vcc_host_5v";
-@@ -45,7 +45,7 @@
- 
- 	vcc_host1_5v: vcc_otg_5v: vcc-host1-5v-regulator {
- 		compatible = "regulator-fixed";
--		gpio = <&gpio0 RK_PA2 GPIO_ACTIVE_LOW>;
-+		gpio = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
- 		pinctrl-names = "default";
- 		pinctrl-0 = <&usb20_host_drv>;
- 		regulator-name = "vcc_host1_5v";
---- a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-+++ b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-@@ -32,7 +32,7 @@
- 		vin-supply = <&vcc_io>;
- 	};
- 
--	vcc_host_5v: vcc-host-5v-regulator {
-+	vcc_host_5v: vcc_host1_5v: vcc_otg_5v: vcc-host-5v-regulator {
- 		compatible = "regulator-fixed";
- 		gpio = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
- 		pinctrl-names = "default";
-@@ -43,22 +43,9 @@
- 		vin-supply = <&vcc_sys>;
- 	};
- 
--	vcc_host1_5v: vcc_otg_5v: vcc-host1-5v-regulator {
--		compatible = "regulator-fixed";
--		gpio = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
--		pinctrl-names = "default";
--		pinctrl-0 = <&usb20_host_drv>;
--		regulator-name = "vcc_host1_5v";
--		regulator-always-on;
--		regulator-boot-on;
--		vin-supply = <&vcc_sys>;
--	};
--
- 	vcc_sys: vcc-sys {
- 		compatible = "regulator-fixed";
- 		regulator-name = "vcc_sys";
--		regulator-always-on;
--		regulator-boot-on;
- 		regulator-min-microvolt = <5000000>;
- 		regulator-max-microvolt = <5000000>;
- 	};
-@@ -132,6 +119,7 @@
- &emmc {
- 	bus-width = <8>;
- 	cap-mmc-highspeed;
-+	mmc-ddr-1_8v;
- 	mmc-hs200-1_8v;
- 	non-removable;
- 	pinctrl-names = "default";
-@@ -145,11 +133,12 @@
- 	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
- 	assigned-clock-parents = <&gmac_clkin>, <&gmac_clkin>;
- 	clock_in_out = "input";
--	phy-supply = <&vcc_io>;
- 	phy-mode = "rgmii";
-+	phy-supply = <&vcc_io>;
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&rgmiim1_pins>;
--	snps,force_thresh_dma_mode;
-+	snps,aal;
-+	snps,pbl = <0x4>;
- 	snps,reset-gpio = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>;
- 	snps,reset-active-low;
- 	snps,reset-delays-us = <0 10000 50000>;
-@@ -188,7 +177,7 @@
- 		vcc3-supply = <&vcc_sys>;
- 		vcc4-supply = <&vcc_sys>;
- 		vcc5-supply = <&vcc_io>;
--		vcc6-supply = <&vcc_sys>;
-+		vcc6-supply = <&vcc_io>;
- 
- 		regulators {
- 			vdd_logic: DCDC_REG1 {
-@@ -295,7 +295,7 @@
- 	vccio1-supply = <&vcc_io>;
- 	vccio2-supply = <&vcc18_emmc>;
- 	vccio3-supply = <&vcc_io>;
--	vccio4-supply = <&vcc_18>;
-+	vccio4-supply = <&vcc_io>;
- 	vccio5-supply = <&vcc_io>;
- 	vccio6-supply = <&vcc_io>;
- 	pmuio-supply = <&vcc_io>;
-@@ -326,7 +315,6 @@
- 	cap-mmc-highspeed;
- 	cap-sd-highspeed;
- 	disable-wp;
--	max-frequency = <150000000>;
- 	pinctrl-names = "default";
- 	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_dectn &sdmmc0_bus4>;
- 	vmmc-supply = <&vcc_sd>;
-@@ -368,14 +356,14 @@
- 
- &u2phy {
- 	status = "okay";
-+};
- 
--	u2phy_host: host-port {
--		status = "okay";
--	};
-+&u2phy_host {
-+	status = "okay";
-+};
- 
--	u2phy_otg: otg-port {
--		status = "okay";
--	};
-+&u2phy_otg {
-+	status = "okay";
- };
- 
- &usb20_otg {
diff --git a/target/linux/rockchip/patches-5.4/0003-usb3_fixes.patch b/target/linux/rockchip/patches-5.4/0003-usb3_fixes.patch
deleted file mode 100644
index 68263686dc..0000000000
--- a/target/linux/rockchip/patches-5.4/0003-usb3_fixes.patch
+++ /dev/null
@@ -1,126 +0,0 @@
-From 47617b87407d583ed22591a565b6e1bb716b2876 Mon Sep 17 00:00:00 2001
-From: William Wu <william.wu@rock-chips.com>
-Date: Mon, 4 Dec 2017 10:40:38 +0100
-Subject: [PATCH] dt-bindings: usb: add DT binding for RK3328 dwc3 controller
-
-Adds the device tree bindings description for RK3328 and
-compatible USB DWC3 controller.
-
-Signed-off-by: William Wu <william.wu@rock-chips.com>
-Acked-by: Rob Herring <robh@kernel.org>
-Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
-Signed-off-by: Heiko Stuebner <heiko@sntech.de>
----
- Documentation/devicetree/bindings/usb/rockchip,dwc3.txt | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
-diff --git a/Documentation/devicetree/bindings/usb/rockchip,dwc3.txt b/Documentation/devicetree/bindings/usb/rockchip,dwc3.txt
-index c8c4b00ecb94..4ca357835a48 100644
---- a/Documentation/devicetree/bindings/usb/rockchip,dwc3.txt
-+++ b/Documentation/devicetree/bindings/usb/rockchip,dwc3.txt
-@@ -1,7 +1,9 @@
- Rockchip SuperSpeed DWC3 USB SoC controller
- 
- Required properties:
--- compatible:	should contain "rockchip,rk3399-dwc3" for rk3399 SoC
-+- compatible:	should be one of the following:
-+  - "rockchip,rk3399-dwc3": for rk3399 SoC
-+  - "rockchip,rk3328-dwc3", "rockchip,rk3399-dwc3": for rk3328 SoC
- - clocks:	A list of phandle + clock-specifier pairs for the
- 		clocks listed in clock-names
- - clock-names:	Should contain the following:
-
-From 45d171c2532e90406a72aa1c24a8d6a7b6d32e67 Mon Sep 17 00:00:00 2001
-From: William Wu <william.wu@rock-chips.com>
-Date: Mon, 4 Dec 2017 10:40:39 +0100
-Subject: [PATCH] arm64: dts: rockchip: add usb3 controller node for RK3328
- SoCs
-
-RK3328 has one USB 3.0 OTG controller which uses DWC_USB3
-core's general architecture. It can act as static xHCI host
-controller, static device controller, USB 3.0/2.0 OTG basing
-on ID of USB3.0 PHY.
-
-Signed-off-by: William Wu <william.wu@rock-chips.com>
-Signed-off-by: Heiko Stuebner <heiko@sntech.de>
----
- arch/arm64/boot/dts/rockchip/rk3328.dtsi | 32 ++++++++++++++++++++++++++++++++
- 1 file changed, 32 insertions(+)
-
-diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-index 8c9b7c3fcee4..901c525deb27 100644
---- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-@@ -953,6 +953,38 @@
- 		status = "disabled";
- 	};
- 
-+	usbdrd3: usb@ff600000 {
-+		compatible = "rockchip,rk3328-dwc3", "rockchip,rk3399-dwc3";
-+		clocks = <&cru SCLK_USB3OTG_REF>, <&cru SCLK_USB3OTG_SUSPEND>,
-+			 <&cru ACLK_USB3OTG>;
-+		clock-names = "ref_clk", "suspend_clk",
-+			      "bus_clk";
-+		resets = <&cru SRST_USB3OTG>;
-+		reset-names = "usb3-otg";
-+		#address-cells = <2>;
-+		#size-cells = <2>;
-+		ranges;
-+		status = "disabled";
-+
-+		usbdrd_dwc3: dwc3@ff600000 {
-+			compatible = "snps,dwc3";
-+			reg = <0x0 0xff600000 0x0 0x100000>;
-+			interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
-+			clocks = <&cru SCLK_USB3OTG_REF>, <&cru ACLK_USB3OTG>,
-+				 <&cru SCLK_USB3OTG_SUSPEND>;
-+			clock-names = "ref", "bus_early", "suspend";
-+			dr_mode = "otg";
-+			phy_type = "utmi_wide";
-+			snps,dis_enblslpm_quirk;
-+			snps,dis-u2-freeclk-exists-quirk;
-+			snps,dis_u2_susphy_quirk;
-+			snps,dis_u3_susphy_quirk;
-+			snps,dis-del-phy-power-chg-quirk;
-+			snps,dis-tx-ipgap-linecheck-quirk;
-+			status = "disabled";
-+		};
-+	};
-+
- 	gic: interrupt-controller@ff811000 {
- 		compatible = "arm,gic-400";
- 		#interrupt-cells = <3>;
-
-From 52d7041671876e508888c5fa892a23e2a0cd1874 Mon Sep 17 00:00:00 2001
-From: Heiko Stuebner <heiko@sntech.de>
-Date: Mon, 4 Dec 2017 10:40:41 +0100
-Subject: [PATCH] arm64: dts: rockchip: enable usb3 nodes on rk3328-rock64
-
-Enable the nodes to make the usb3 port usable on that board.
-
-Signed-off-by: Heiko Stuebner <heiko@sntech.de>
----
- arch/arm64/boot/dts/rockchip/rk3328-rock64.dts | 9 +++++++++
- 1 file changed, 9 insertions(+)
-
-diff --git a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-index 345c045c58e6..1cc3a8f5c3d7 100644
---- a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-+++ b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-@@ -379,6 +379,15 @@
- 	status = "okay";
- };
- 
-+&usbdrd3 {
-+	status = "okay";
-+};
-+
-+&usbdrd_dwc3 {
-+	dr_mode = "host";
-+	status = "okay";
-+};
-+
- &vop {
- 	status = "okay";
- };
-
diff --git a/target/linux/rockchip/patches-5.4/0005-fix_TX_checksumm_offload.patch b/target/linux/rockchip/patches-5.4/0005-fix_TX_checksumm_offload.patch
deleted file mode 100644
index fe2de5ef36..0000000000
--- a/target/linux/rockchip/patches-5.4/0005-fix_TX_checksumm_offload.patch
+++ /dev/null
@@ -1,57 +0,0 @@
-From patchwork Tue Feb 18 22:10:37 2020
-From: Carlos de Paula <me@carlosedp.com>
-Subject: [PATCH] arm64: dts: rockchip: Add txpbl node for RK3399/RK3328
-Date: Tue, 18 Feb 2020 17:10:37 -0500
-Sender: linux-kernel-owner@vger.kernel.org
-
-Some rockchip SoCs like the RK3399 and RK3328 exhibit an issue
-where tx checksumming does not work with packets larger than 1498.
-
-The default Programmable Buffer Length for TX in these GMAC's is
-not suitable for MTUs higher than 1498. The workaround is to disable
-TX offloading with 'ethtool -K eth0 tx off rx off' causing performance
-impacts as it disables hardware checksumming.
-
-This patch sets snps,txpbl to 0x4 which is a safe number tested ok for
-the most popular MTU value of 1500.
-
-For reference, see https://lkml.org/lkml/2019/4/1/1382.
-
-Signed-off-by: Carlos de Paula <me@carlosedp.com>
----
- arch/arm64/boot/dts/rockchip/rk3328.dtsi | 2 ++
- arch/arm64/boot/dts/rockchip/rk3399.dtsi | 1 +
- 2 files changed, 3 insertions(+)
-
-diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-index 1f53ead52c7f..b7f1de4b7fd0 100644
---- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-@@ -874,6 +874,7 @@
- 		resets = <&cru SRST_GMAC2IO_A>;
- 		reset-names = "stmmaceth";
- 		rockchip,grf = <&grf>;
-+		snps,txpbl = <0x4>;
- 		status = "disabled";
- 	};
- 
-@@ -881,6 +882,7 @@
- 		compatible = "rockchip,rk3328-gmac";
- 		reg = <0x0 0xff550000 0x0 0x10000>;
- 		rockchip,grf = <&grf>;
-+		snps,txpbl = <0x4>;
- 		interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
- 		interrupt-names = "macirq";
- 		clocks = <&cru SCLK_MAC2PHY_SRC>, <&cru SCLK_MAC2PHY_RXTX>,
-diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
-index 33cc21fcf4c1..cd5415d7e559 100644
---- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
-+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
-@@ -288,6 +288,7 @@
- 		resets = <&cru SRST_A_GMAC>;
- 		reset-names = "stmmaceth";
- 		rockchip,grf = <&grf>;
-+		snps,txpbl = <0x4>;
- 		status = "disabled";
- 	};
- 
diff --git a/target/linux/rockchip/patches-5.4/0006-rk3328_add_sdmmc_ext_node.patch b/target/linux/rockchip/patches-5.4/0006-rk3328_add_sdmmc_ext_node.patch
deleted file mode 100644
index 829ff9014c..0000000000
--- a/target/linux/rockchip/patches-5.4/0006-rk3328_add_sdmmc_ext_node.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From 480b56effc7d96a1f87ee50e055ba2936fdad1f8 Mon Sep 17 00:00:00 2001
-From: Jonas Karlman <jonas@kwiboo.se>
-Date: Sun, 29 Dec 2019 22:14:02 +0000
-Subject: [PATCH] arm64: dts: rockchip: add sdmmc_ext node on rk3328
-
----
- arch/arm64/boot/dts/rockchip/rk3328.dtsi | 14 ++++++++++++++
- 1 file changed, 14 insertions(+)
-
-diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-index 3c50c11c2e5b..1c8057c7bcd3 100644
---- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-@@ -987,6 +987,20 @@
- 		};
- 	};
- 
-+	sdmmc_ext: mmc@ff5f0000 {
-+		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
-+		reg = <0x0 0xff5f0000 0x0 0x4000>;
-+		interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
-+		clocks = <&cru HCLK_SDMMC_EXT>, <&cru SCLK_SDMMC_EXT>,
-+			 <&cru SCLK_SDMMC_EXT_DRV>, <&cru SCLK_SDMMC_EXT_SAMPLE>;
-+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
-+		fifo-depth = <0x100>;
-+		max-frequency = <150000000>;
-+		resets = <&cru SRST_SDMMCEXT>;
-+		reset-names = "reset";
-+		status = "disabled";
-+	};
-+
- 	gic: interrupt-controller@ff811000 {
- 		compatible = "arm,gic-400";
- 		#interrupt-cells = <3>;
diff --git a/target/linux/rockchip/patches-5.4/0007-rk3328_add_mmc_reset.patch b/target/linux/rockchip/patches-5.4/0007-rk3328_add_mmc_reset.patch
deleted file mode 100644
index c66fbfbbaf..0000000000
--- a/target/linux/rockchip/patches-5.4/0007-rk3328_add_mmc_reset.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From 764e6cf1c0ffcfdbac7a259bc3ce4a7c4f221f75 Mon Sep 17 00:00:00 2001
-From: Jonas Karlman <jonas@kwiboo.se>
-Date: Sun, 29 Dec 2019 22:13:22 +0000
-Subject: [PATCH] arm64: dts: rockchip: add mmc reset on rk3328
-
----
- arch/arm64/boot/dts/rockchip/rk3328.dtsi | 6 ++++++
- 1 file changed, 6 insertions(+)
-
-diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-index 635f68fdc85c..3c50c11c2e5b 100644
---- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-@@ -831,6 +831,8 @@
- 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
- 		fifo-depth = <0x100>;
- 		max-frequency = <150000000>;
-+		resets = <&cru SRST_MMC0>;
-+		reset-names = "reset";
- 		status = "disabled";
- 	};
- 
-@@ -843,6 +845,8 @@
- 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
- 		fifo-depth = <0x100>;
- 		max-frequency = <150000000>;
-+		resets = <&cru SRST_SDIO>;
-+		reset-names = "reset";
- 		status = "disabled";
- 	};
- 
-@@ -855,6 +859,8 @@
- 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
- 		fifo-depth = <0x100>;
- 		max-frequency = <150000000>;
-+		resets = <&cru SRST_EMMC>;
-+		reset-names = "reset";
- 		status = "disabled";
- 	};
- 
diff --git a/target/linux/rockchip/patches-5.4/0010-mmc_rename.patch b/target/linux/rockchip/patches-5.4/0010-mmc_rename.patch
deleted file mode 100644
index f1ecd8e0b4..0000000000
--- a/target/linux/rockchip/patches-5.4/0010-mmc_rename.patch
+++ /dev/null
@@ -1,56 +0,0 @@
-From 3ef7c2558f31745588473b75a655894b37e62116 Mon Sep 17 00:00:00 2001
-From: Johan Jonker <jbx6244@gmail.com>
-Date: Wed, 15 Jan 2020 19:52:44 +0100
-Subject: arm64: dts: rockchip: rename dwmmc node names to mmc
-
-Current dts files with 'dwmmc' nodes are manually verified.
-In order to automate this process rockchip-dw-mshc.txt
-has to be converted to yaml. In the new setup
-rockchip-dw-mshc.yaml will inherit properties from
-mmc-controller.yaml and synopsys-dw-mshc-common.yaml.
-'dwmmc' will no longer be a valid name for a node,
-so change them all to 'mmc'
-
-Signed-off-by: Johan Jonker <jbx6244@gmail.com>
-Link: https://lore.kernel.org/r/20200115185244.18149-2-jbx6244@gmail.com
-Signed-off-by: Heiko Stuebner <heiko@sntech.de>
----
- arch/arm64/boot/dts/rockchip/rk3328.dtsi | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
-
-(limited to 'arch/arm64/boot/dts/rockchip/rk3328.dtsi')
-
-diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-index c9ff1188bd7b..1f53ead52c7f 100644
---- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-@@ -822,7 +822,7 @@
- 		};
- 	};
- 
--	sdmmc: dwmmc@ff500000 {
-+	sdmmc: mmc@ff500000 {
- 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
- 		reg = <0x0 0xff500000 0x0 0x4000>;
- 		interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
-@@ -836,7 +836,7 @@
- 		status = "disabled";
- 	};
- 
--	sdio: dwmmc@ff510000 {
-+	sdio: mmc@ff510000 {
- 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
- 		reg = <0x0 0xff510000 0x0 0x4000>;
- 		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
-@@ -850,7 +850,7 @@
- 		status = "disabled";
- 	};
- 
--	emmc: dwmmc@ff520000 {
-+	emmc: mmc@ff520000 {
- 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
- 		reg = <0x0 0xff520000 0x0 0x4000>;
- 		interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
--- 
-cgit 1.2-0.3.lf.el7
-
diff --git a/target/linux/rockchip/patches-5.4/0011-rock64_add_spi_flash_partitions.patch b/target/linux/rockchip/patches-5.4/0011-rock64_add_spi_flash_partitions.patch
deleted file mode 100644
index f77746da67..0000000000
--- a/target/linux/rockchip/patches-5.4/0011-rock64_add_spi_flash_partitions.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From 61beaf04441cc521320136cb57b5a42627f0c34a Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Kamil=20Trzci=C5=84ski?= <ayufan@ayufan.eu>
-Date: Sat, 25 May 2019 19:49:57 +0200
-Subject: [PATCH] ayufan: dts: rock64: add spi-flash partitions
-
-Change-Id: I4a925da14a95e2fcce5c9b8d1c4faca3028dd2eb
----
- arch/arm64/boot/dts/rockchip/rk3328-rock64.dts | 14 +++++++++++++-
- 1 file changed, 13 insertions(+), 1 deletion(-)
-
-diff --git a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-index dcb336b49f9bd..d873c17510e93 100644
---- a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-+++ b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-@@ -336,11 +336,23 @@
- 	status = "okay";
- 
- 	spiflash@0 {
--		compatible = "jedec,spi-nor";
-+		compatible = "gigadevice,gd25q128", "jedec,spi-nor";
- 		reg = <0>;
-+		m25p,fast-read;
- 
- 		/* maximum speed for Rockchip SPI */
- 		spi-max-frequency = <50000000>;
-+
-+		partitions {
-+			compatible = "fixed-partitions";
-+			#address-cells = <1>;
-+			#size-cells = <1>;
-+
-+			loader@8000 {
-+				label = "loader";
-+				reg = <0x8000 0x3F0000>;
-+			};
-+		};
- 	};
- };
- 
diff --git a/target/linux/rockchip/patches-5.4/0012-add_sound_rk3328_rock64.patch b/target/linux/rockchip/patches-5.4/0012-add_sound_rk3328_rock64.patch
deleted file mode 100644
index 44b3decdcc..0000000000
--- a/target/linux/rockchip/patches-5.4/0012-add_sound_rk3328_rock64.patch
+++ /dev/null
@@ -1,170 +0,0 @@
---- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
-@@ -159,6 +159,22 @@
- 		};
- 	};
- 
-+	analog_sound: analog-sound {
-+		compatible = "simple-audio-card";
-+		simple-audio-card,format = "i2s";
-+		simple-audio-card,mclk-fs = <256>;
-+		simple-audio-card,name = "Analog";
-+		status = "disabled";
-+
-+		simple-audio-card,cpu {
-+			sound-dai = <&i2s1>;
-+		};
-+
-+		simple-audio-card,codec {
-+			sound-dai = <&codec>;
-+		};
-+	};
-+
- 	arm-pmu {
- 		compatible = "arm,cortex-a53-pmu";
- 		interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
-@@ -173,11 +189,47 @@
- 		ports = <&vop_out>;
- 	};
- 
-+	hdmi_sound: hdmi-sound {
-+		compatible = "simple-audio-card";
-+		simple-audio-card,format = "i2s";
-+		simple-audio-card,mclk-fs = <128>;
-+		simple-audio-card,name = "HDMI";
-+		status = "disabled";
-+
-+		simple-audio-card,cpu {
-+			sound-dai = <&i2s0>;
-+		};
-+
-+		simple-audio-card,codec {
-+			sound-dai = <&hdmi>;
-+		};
-+	};
-+
- 	psci {
- 		compatible = "arm,psci-1.0", "arm,psci-0.2";
- 		method = "smc";
- 	};
- 
-+	spdif_out: spdif-out {
-+		compatible = "linux,spdif-dit";
-+		#sound-dai-cells = <0>;
-+		status = "disabled";
-+	};
-+
-+	spdif_sound: spdif-sound {
-+		compatible = "simple-audio-card";
-+		simple-audio-card,name = "SPDIF";
-+		status = "disabled";
-+
-+		simple-audio-card,cpu {
-+			sound-dai = <&spdif>;
-+		};
-+
-+		simple-audio-card,codec {
-+			sound-dai = <&spdif_out>;
-+		};
-+	};
-+
- 	timer {
- 		compatible = "arm,armv8-timer";
- 		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
---- a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-+++ b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
-@@ -70,34 +70,14 @@
- 			linux,default-trigger = "heartbeat";
- 		};
- 	};
-+};
- 
--	sound {
--		compatible = "audio-graph-card";
--		label = "rockchip,rk3328";
--		dais = <&i2s1_p0
--			&spdif_p0>;
--	};
--
--	spdif-dit {
--		compatible = "linux,spdif-dit";
--		#sound-dai-cells = <0>;
--
--		port {
--			dit_p0_0: endpoint {
--				remote-endpoint = <&spdif_p0_0>;
--			};
--		};
--	};
-+&analog_sound {
-+	status = "okay";
- };
- 
- &codec {
- 	status = "okay";
--
--	port@0 {
--		codec_p0_0: endpoint {
--			remote-endpoint = <&i2s1_p0_0>;
--		};
--	};
- };
- 
- &cpu0 {
-@@ -155,6 +135,10 @@
- 	status = "okay";
- };
- 
-+&hdmi_sound {
-+	status = "okay";
-+};
-+
- &i2c1 {
- 	status = "okay";
- 
-@@ -266,21 +250,15 @@
- 	};
- };
- 
--&i2s1 {
-+&i2s0 {
- 	status = "okay";
--
--	i2s1_p0: port {
--		i2s1_p0_0: endpoint {
--			dai-format = "i2s";
--			mclk-fs = <256>;
--			remote-endpoint = <&codec_p0_0>;
--		};
--	};
- };
- 
--&io_domains {
-+&i2s1 {
- 	status = "okay";
-+};
- 
-+&io_domains {
- 	vccio1-supply = <&vcc_io>;
- 	vccio2-supply = <&vcc18_emmc>;
- 	vccio3-supply = <&vcc_io>;
-@@ -324,12 +302,14 @@
- &spdif {
- 	pinctrl-0 = <&spdifm0_tx>;
- 	status = "okay";
-+};
- 
--	spdif_p0: port {
--		spdif_p0_0: endpoint {
--			remote-endpoint = <&dit_p0_0>;
--		};
--	};
-+&spdif_out {
-+	status = "okay";
-+};
-+
-+&spdif_sound {
-+	status = "okay";
- };
- 
- &spi0 {
diff --git a/target/linux/rockchip/patches-5.4/RK3328-enable-1512mhz-opp.patch b/target/linux/rockchip/patches-5.4/RK3328-enable-1512mhz-opp.patch
new file mode 100644
index 0000000000..7d67233d62
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/RK3328-enable-1512mhz-opp.patch
@@ -0,0 +1,16 @@
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+index 8dabc6e29..d58c893a6 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -125,6 +125,11 @@
+ 			opp-microvolt = <1300000>;
+ 			clock-latency-ns = <40000>;
+ 		};
++		opp-1512000000 {
++			opp-hz = /bits/ 64 <1512000000>;
++			opp-microvolt = <1450000>;
++			clock-latency-ns = <40000>;
++		};
+ 	};
+ 
+ 	amba {
diff --git a/target/linux/rockchip/patches-5.4/add-radxa-rock-pi-e.patch b/target/linux/rockchip/patches-5.4/add-radxa-rock-pi-e.patch
new file mode 100644
index 0000000000..888bcc93f0
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/add-radxa-rock-pi-e.patch
@@ -0,0 +1,492 @@
+diff -ruN a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
+--- a/arch/arm64/boot/dts/rockchip/Makefile	2020-05-27 15:46:53.000000000 +0000
++++ b/arch/arm64/boot/dts/rockchip/Makefile	2020-06-07 16:32:59.590211585 +0000
+@@ -3,6 +3,7 @@
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-evb.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-rock64.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-roc-cc.dtb
++dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3328-rock-pi-e.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-evb-act8846.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-geekbox.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3368-lion-haikou.dtb
+diff -ruN a/arch/arm64/boot/dts/rockchip/rk3328-rock-pi-e.dts b/arch/arm64/boot/dts/rockchip/rk3328-rock-pi-e.dts
+--- a/arch/arm64/boot/dts/rockchip/rk3328-rock-pi-e.dts	1970-01-01 00:00:00.000000000 +0000
++++ b/arch/arm64/boot/dts/rockchip/rk3328-rock-pi-e.dts	2020-06-07 16:32:43.789930837 +0000
+@@ -0,0 +1,477 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
++ */
++
++/dts-v1/;
++#include "rk3328.dtsi"
++#include <dt-bindings/input/input.h>
++
++/ {
++	model = "Radxa Rock Pi E";
++	compatible = "radxa,rock-pi-e", "rockchip,rk3328";
++
++	chosen {
++		stdout-path = "serial2:1500000n8";
++	};
++
++	fiq_debugger: fiq-debugger {
++		compatible = "rockchip,fiq-debugger";
++		rockchip,serial-id = <2>;
++		rockchip,signal-irq = <159>;
++		rockchip,wake-irq = <0>;
++		/* If enable uart uses irq instead of fiq */
++		rockchip,irq-mode-enable = <0>;
++		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
++		interrupts = <GIC_SPI 127 IRQ_TYPE_LEVEL_LOW>;
++		status = "disabled";
++	};
++
++	gmac_clkin: external-gmac-clock {
++		compatible = "fixed-clock";
++		clock-frequency = <125000000>;
++		clock-output-names = "gmac_clkin";
++		#clock-cells = <0>;
++	};
++
++	sound {
++		compatible = "simple-audio-card";
++		simple-audio-card,format = "i2s";
++		simple-audio-card,mclk-fs = <256>;
++		simple-audio-card,name = "rockchip,rk3328";
++		simple-audio-card,cpu {
++			sound-dai = <&i2s1>;
++		};
++		simple-audio-card,codec {
++			sound-dai = <&codec>;
++		};
++	};
++
++	hdmi-sound {
++		compatible = "simple-audio-card";
++		simple-audio-card,format = "i2s";
++		simple-audio-card,mclk-fs = <128>;
++		simple-audio-card,name = "rockchip,hdmi";
++		simple-audio-card,cpu {
++			sound-dai = <&i2s0>;
++		};
++		simple-audio-card,codec {
++			sound-dai = <&hdmi>;
++		};
++	};
++
++	vcc_host_vbus: host-vbus-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio3 RK_PA7 GPIO_ACTIVE_HIGH>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&host_vbus_drv>;
++		regulator-name = "vcc_host_vbus";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		enable-active-high;
++	};
++
++	vcc_phy: vcc-phy-regulator {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_phy";
++		regulator-always-on;
++		regulator-boot-on;
++	};
++
++	vcc_sys: vcc-sys {
++		compatible = "regulator-fixed";
++		regulator-name = "vcc_sys";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++	};
++
++	vcc_sd: sdmmc-regulator {
++		compatible = "regulator-fixed";
++		gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_LOW>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&sdmmc0m1_gpio>;
++		regulator-name = "vcc_sd";
++		regulator-always-on;
++		regulator-boot-on;
++		regulator-min-microvolt = <3300000>;
++		regulator-max-microvolt = <3300000>;
++		vin-supply = <&vcc_io>;
++	};
++
++	xin32k: xin32k {
++		compatible = "fixed-clock";
++		clock-frequency = <32768>;
++		clock-output-names = "xin32k";
++		#clock-cells = <0>;
++	};
++
++	leds {
++		compatible = "gpio-leds";
++		status = "okay";
++
++		user {
++			label = "rockpi:green:user";
++			gpios = <&gpio3 5 GPIO_ACTIVE_LOW>;
++			linux,default-trigger = "heartbeat";
++			default-state = "on";
++		};
++	};
++};
++
++&io_domains {
++	status = "okay";
++
++	vccio1-supply = <&vcc_io>;
++	vccio2-supply = <&vcc_18emmc>;
++	vccio3-supply = <&vcc_io>;
++	vccio4-supply = <&vcc_io>;
++	vccio5-supply = <&vcc_io>;
++	vccio6-supply = <&vcc_io>;
++	pmuio-supply = <&vcc_io>;
++};
++
++&cpu0 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu1 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu2 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&cpu3 {
++	cpu-supply = <&vdd_arm>;
++};
++
++&gpu {
++	status = "okay";
++	mali-supply = <&vdd_logic>;
++};
++
++&gmac2phy {
++	phy-supply = <&vcc_phy>;
++	clock_in_out = "output";
++	assigned-clocks = <&cru SCLK_MAC2PHY_SRC>;
++	assigned-clock-rate = <50000000>;
++	assigned-clocks = <&cru SCLK_MAC2PHY>;
++	assigned-clock-parents = <&cru SCLK_MAC2PHY_SRC>;
++	snps,txpbl = <0x4>;
++	status = "okay";
++};
++
++&gmac2io {
++	phy-supply = <&vcc_io>;
++	phy-mode = "rgmii";
++	clock_in_out = "input";
++	snps,reset-gpio = <&gpio1 RK_PC2 GPIO_ACTIVE_LOW>;
++	snps,reset-active-low;
++	snps,reset-delays-us = <0 10000 50000>;
++	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
++	assigned-clock-parents = <&gmac_clkin>, <&gmac_clkin>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmiim1_pins>;
++	snps,txpbl = <0x4>;
++	tx_delay = <0x26>;
++	rx_delay = <0x11>;
++	status = "okay";
++};
++
++&display_subsystem {
++	status = "okay";
++};
++
++&hdmi {
++	#sound-dai-cells = <0>;
++	ddc-i2c-scl-high-time-ns = <9625>;
++	ddc-i2c-scl-low-time-ns = <10000>;
++	status = "okay";
++};
++
++&hdmiphy {
++	status = "okay";
++};
++
++&vop {
++	status = "okay";
++};
++
++&vop_mmu {
++	status = "okay";
++};
++
++&i2s0 {
++	#sound-dai-cells = <0>;
++	rockchip,bclk-fs = <128>;
++	status = "okay";
++};
++
++&i2s1 {
++	#sound-dai-cells = <0>;
++	status = "okay";
++};
++
++&codec {
++	#sound-dai-cells = <0>;
++	status = "okay";
++};
++
++&emmc {
++	bus-width = <8>;
++	cap-mmc-highspeed;
++	max-frequency = <150000000>;
++	mmc-ddr-1_8v;
++	mmc-hs200-1_8v;
++	supports-emmc;
++	disable-wp;
++	non-removable;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
++	vmmc-supply = <&vcc_io>;
++	vqmmc-supply = <&vcc_18emmc>;
++	status = "okay";
++};
++
++&sdmmc {
++	bus-width = <4>;
++	cap-mmc-highspeed;
++	cap-sd-highspeed;
++	card-detect-delay = <200>;
++	disable-wp;
++	max-frequency = <150000000>;
++	num-slots = <1>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_dectn &sdmmc0_bus4>;
++	supports-sd;
++	vmmc-supply = <&vcc_sd>;
++	status = "okay";
++};
++
++&i2c1 {
++	status = "okay";
++
++	rk805: rk805@18 {
++		compatible = "rockchip,rk805";
++		status = "okay";
++		reg = <0x18>;
++		interrupt-parent = <&gpio2>;
++		interrupts = <6 IRQ_TYPE_LEVEL_LOW>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&pmic_int_l>;
++		rockchip,system-power-controller;
++		wakeup-source;
++		gpio-controller;
++		#gpio-cells = <2>;
++		#clock-cells = <1>;
++		clock-output-names = "xin32k", "rk805-clkout2";
++
++		vcc1-supply = <&vcc_sys>;
++		vcc2-supply = <&vcc_sys>;
++		vcc3-supply = <&vcc_sys>;
++		vcc4-supply = <&vcc_sys>;
++		vcc5-supply = <&vcc_io>;
++		vcc6-supply = <&vcc_sys>;
++
++		rtc {
++			status = "okay";
++		};
++
++		pwrkey {
++			status = "disabled";
++		};
++
++		gpio {
++			status = "okay";
++		};
++
++		regulators {
++			vdd_logic: DCDC_REG1 {
++				regulator-name = "vdd_logic";
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-initial-mode = <0x1>;
++				regulator-ramp-delay = <12500>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-mode = <0x2>;
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1000000>;
++				};
++			};
++
++			vdd_arm: DCDC_REG2 {
++				regulator-name = "vdd_arm";
++				regulator-min-microvolt = <712500>;
++				regulator-max-microvolt = <1450000>;
++				regulator-initial-mode = <0x1>;
++				regulator-ramp-delay = <12500>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-mode = <0x2>;
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <950000>;
++				};
++			};
++
++			vcc_ddr: DCDC_REG3 {
++				regulator-name = "vcc_ddr";
++				regulator-initial-mode = <0x1>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-mode = <0x2>;
++					regulator-on-in-suspend;
++				};
++			};
++
++			vcc_io: DCDC_REG4 {
++				regulator-name = "vcc_io";
++				regulator-min-microvolt = <3300000>;
++				regulator-max-microvolt = <3300000>;
++				regulator-initial-mode = <0x1>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-mode = <0x2>;
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <3300000>;
++				};
++			};
++
++			vdd_18: LDO_REG1 {
++				regulator-name = "vdd_18";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vcc_18emmc: LDO_REG2 {
++				regulator-name = "vcc_18emmc";
++				regulator-min-microvolt = <1800000>;
++				regulator-max-microvolt = <1800000>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1800000>;
++				};
++			};
++
++			vdd_11: LDO_REG3 {
++				regulator-name = "vdd_11";
++				regulator-min-microvolt = <1100000>;
++				regulator-max-microvolt = <1100000>;
++				regulator-boot-on;
++				regulator-always-on;
++				regulator-state-mem {
++					regulator-on-in-suspend;
++					regulator-suspend-microvolt = <1100000>;
++				};
++			};
++		};
++	};
++};
++
++&pinctrl {
++	pinctrl-names = "default";
++	pinctrl-0 = <&wifi_enable>;
++
++	wifi {
++		wifi_enable: wifi-enable {
++			rockchip,pins =
++				<0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_down>;
++		};
++	};
++
++	pmic {
++		pmic_int_l: pmic-int-l {
++			rockchip,pins =
++				<2 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>;	/* gpio2_a6 */
++		};
++	};
++
++	usb {
++		host_vbus_drv: host-vbus-drv {
++			rockchip,pins =
++				<3 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++};
++
++&u2phy {
++	status = "okay";
++};
++
++&u2phy_host {
++	status = "okay";
++};
++
++&u2phy_otg {
++	status = "okay";
++};
++
++&u3phy {
++	vbus-supply = <&vcc_host_vbus>;
++	status = "okay";
++};
++
++&u3phy_utmi {
++	status = "okay";
++};
++
++&u3phy_pipe {
++	status = "okay";
++};
++
++&uart2 {
++	status = "okay";
++};
++
++&usb20_otg {
++	dr_mode = "host";
++	status = "okay";
++};
++
++&usb_host0_ehci {
++	status = "okay";
++};
++
++&usb_host0_ohci {
++	status = "okay";
++};
++
++&usbdrd3 {
++	status = "okay";
++};
++
++&usbdrd_dwc3 {
++	dr_mode = "host";
++	status = "okay";
++};
++
++&wdt {
++	status = "okay";
++};
++
++&saradc {
++	status = "okay";
++	vref-supply = <&vdd_18>;
++};
++
++&tsadc {
++	status = "okay";
++	rockchip,hw-tshut-mode = <1>; /* tshut mode 0:CRU 1:GPIO */
++	rockchip,hw-tshut-polarity = <1>; /* tshut polarity 0:LOW 1:HIGH */
++};
diff --git a/target/linux/rockchip/patches-5.4/add-rk3328-usb3-phy-driver.patch b/target/linux/rockchip/patches-5.4/add-rk3328-usb3-phy-driver.patch
new file mode 100644
index 0000000000..7ac1a2e432
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/add-rk3328-usb3-phy-driver.patch
@@ -0,0 +1,1504 @@
+Add the rockchip innosilicon usb3 phy driver, supporting devices such as the rk3328.
+Pulled from:
+https://github.com/FireflyTeam/kernel/blob/roc-rk3328-cc/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+
+Signed-off-by: Peter Geis <pgwipeout@gmail.com>
+---
+ drivers/phy/rockchip/Kconfig                  |    9 +
+ drivers/phy/rockchip/Makefile                 |    1 +
+ drivers/phy/rockchip/phy-rockchip-inno-usb3.c | 1107 +++++++++++++++++
+ 3 files changed, 1117 insertions(+)
+ create mode 100644 drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+
+diff --git a/drivers/phy/rockchip/Kconfig b/drivers/phy/rockchip/Kconfig
+index c454c90cd99e..766407939d4a 100644
+--- a/drivers/phy/rockchip/Kconfig
++++ b/drivers/phy/rockchip/Kconfig
+@@ -35,6 +35,15 @@ config PHY_ROCKCHIP_INNO_USB2
+ 	help
+ 	  Support for Rockchip USB2.0 PHY with Innosilicon IP block.
+ 
++config PHY_ROCKCHIP_INNO_USB3
++	tristate "Rockchip INNO USB 3.0 PHY Driver"
++	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
++	depends on USB_SUPPORT
++	select GENERIC_PHY
++	select USB_PHY
++	help
++	  Support for Rockchip USB 3.0 PHY with Innosilicon IP block.
++
+ config PHY_ROCKCHIP_PCIE
+ 	tristate "Rockchip PCIe PHY Driver"
+ 	depends on (ARCH_ROCKCHIP && OF) || COMPILE_TEST
+diff --git a/drivers/phy/rockchip/Makefile b/drivers/phy/rockchip/Makefile
+index fd21cbaf40dd..d7b3d16c19ae 100644
+--- a/drivers/phy/rockchip/Makefile
++++ b/drivers/phy/rockchip/Makefile
+@@ -3,6 +3,7 @@ obj-$(CONFIG_PHY_ROCKCHIP_DP)		+= phy-rockchip-dp.o
+ obj-$(CONFIG_PHY_ROCKCHIP_EMMC)		+= phy-rockchip-emmc.o
+ obj-$(CONFIG_PHY_ROCKCHIP_INNO_HDMI)	+= phy-rockchip-inno-hdmi.o
+ obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB2)	+= phy-rockchip-inno-usb2.o
++obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB3)	+= phy-rockchip-inno-usb3.o
+ obj-$(CONFIG_PHY_ROCKCHIP_PCIE)		+= phy-rockchip-pcie.o
+ obj-$(CONFIG_PHY_ROCKCHIP_TYPEC)	+= phy-rockchip-typec.o
+ obj-$(CONFIG_PHY_ROCKCHIP_USB)		+= phy-rockchip-usb.o
+diff --git a/drivers/phy/rockchip/phy-rockchip-inno-usb3.c b/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+new file mode 100644
+index 000000000000..31fee8f3a705
+--- /dev/null
++++ b/drivers/phy/rockchip/phy-rockchip-inno-usb3.c
+@@ -0,0 +1,1107 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * Rockchip USB 3.0 PHY with Innosilicon IP block driver
++ *
++ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
++ */
++
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/debugfs.h>
++#include <linux/gpio/consumer.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_clk.h>
++#include <linux/of_irq.h>
++#include <linux/of_platform.h>
++#include <linux/phy/phy.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++#include <linux/reset.h>
++#include <linux/usb/phy.h>
++#include <linux/uaccess.h>
++
++#define U3PHY_PORT_NUM	2
++#define BIT_WRITEABLE_SHIFT	16
++#define SCHEDULE_DELAY	(60 * HZ)
++
++#define U3PHY_APB_RST	BIT(0)
++#define U3PHY_POR_RST	BIT(1)
++#define U3PHY_MAC_RST	BIT(2)
++
++struct rockchip_u3phy;
++struct rockchip_u3phy_port;
++
++enum rockchip_u3phy_type {
++	U3PHY_TYPE_PIPE,
++	U3PHY_TYPE_UTMI,
++};
++
++enum rockchip_u3phy_pipe_pwr {
++	PIPE_PWR_P0	= 0,
++	PIPE_PWR_P1	= 1,
++	PIPE_PWR_P2	= 2,
++	PIPE_PWR_P3	= 3,
++	PIPE_PWR_MAX	= 4,
++};
++
++enum rockchip_u3phy_rest_req {
++	U3_POR_RSTN	= 0,
++	U2_POR_RSTN	= 1,
++	PIPE_MAC_RSTN	= 2,
++	UTMI_MAC_RSTN	= 3,
++	PIPE_APB_RSTN	= 4,
++	UTMI_APB_RSTN	= 5,
++	U3PHY_RESET_MAX	= 6,
++};
++
++enum rockchip_u3phy_utmi_state {
++	PHY_UTMI_HS_ONLINE	= 0,
++	PHY_UTMI_DISCONNECT	= 1,
++	PHY_UTMI_CONNECT	= 2,
++	PHY_UTMI_FS_LS_ONLINE	= 4,
++};
++
++/*
++ * @rvalue: reset value
++ * @dvalue: desired value
++ */
++struct u3phy_reg {
++	unsigned int	offset;
++	unsigned int	bitend;
++	unsigned int	bitstart;
++	unsigned int	rvalue;
++	unsigned int	dvalue;
++};
++
++struct rockchip_u3phy_grfcfg {
++	struct u3phy_reg	um_suspend;
++	struct u3phy_reg	ls_det_en;
++	struct u3phy_reg	ls_det_st;
++	struct u3phy_reg	um_ls;
++	struct u3phy_reg	um_hstdct;
++	struct u3phy_reg	u2_only_ctrl;
++	struct u3phy_reg	u3_disable;
++	struct u3phy_reg	pp_pwr_st;
++	struct u3phy_reg	pp_pwr_en[PIPE_PWR_MAX];
++};
++
++/**
++ * struct rockchip_u3phy_apbcfg: usb3-phy apb configuration.
++ * @u2_pre_emp: usb2-phy pre-emphasis tuning.
++ * @u2_pre_emp_sth: usb2-phy pre-emphasis strength tuning.
++ * @u2_odt_tuning: usb2-phy odt 45ohm tuning.
++ */
++struct rockchip_u3phy_apbcfg {
++	unsigned int	u2_pre_emp;
++	unsigned int	u2_pre_emp_sth;
++	unsigned int	u2_odt_tuning;
++};
++
++struct rockchip_u3phy_cfg {
++	unsigned int reg;
++	const struct rockchip_u3phy_grfcfg grfcfg;
++
++	int (*phy_pipe_power)(struct rockchip_u3phy *u3phy,
++			      struct rockchip_u3phy_port *u3phy_port,
++			      bool on);
++	int (*phy_tuning)(struct rockchip_u3phy *u3phy,
++			  struct rockchip_u3phy_port *u3phy_port,
++			  struct device_node *child_np);
++};
++
++struct rockchip_u3phy_port {
++	struct phy	*phy;
++	void __iomem	*base;
++	unsigned int	index;
++	unsigned char	type;
++	bool		suspended;
++	bool		refclk_25m_quirk;
++	struct mutex	mutex; /* mutex for updating register */
++	struct delayed_work	um_sm_work;
++};
++
++struct rockchip_u3phy {
++	struct device *dev;
++	struct regmap *u3phy_grf;
++	struct regmap *grf;
++	int um_ls_irq;
++	struct clk **clks;
++	int num_clocks;
++	struct dentry *root;
++	struct gpio_desc *vbus_drv_gpio;
++	struct reset_control *rsts[U3PHY_RESET_MAX];
++	struct rockchip_u3phy_apbcfg apbcfg;
++	const struct rockchip_u3phy_cfg *cfgs;
++	struct rockchip_u3phy_port ports[U3PHY_PORT_NUM];
++	struct usb_phy usb_phy;
++};
++
++static inline int param_write(void __iomem *base,
++			      const struct u3phy_reg *reg, bool desired)
++{
++	unsigned int val, mask;
++	unsigned int tmp = desired ? reg->dvalue : reg->rvalue;
++	int ret = 0;
++
++	mask = GENMASK(reg->bitend, reg->bitstart);
++	val = (tmp << reg->bitstart) | (mask << BIT_WRITEABLE_SHIFT);
++	ret = regmap_write(base, reg->offset, val);
++
++	return ret;
++}
++
++static inline bool param_exped(void __iomem *base,
++			       const struct u3phy_reg *reg,
++			       unsigned int value)
++{
++	int ret;
++	unsigned int tmp, orig;
++	unsigned int mask = GENMASK(reg->bitend, reg->bitstart);
++
++	ret = regmap_read(base, reg->offset, &orig);
++	if (ret)
++		return false;
++
++	tmp = (orig & mask) >> reg->bitstart;
++	return tmp == value;
++}
++
++static int rockchip_u3phy_usb2_only_show(struct seq_file *s, void *unused)
++{
++	struct rockchip_u3phy	*u3phy = s->private;
++
++	if (param_exped(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.u2_only_ctrl, 1))
++		dev_info(u3phy->dev, "u2\n");
++	else
++		dev_info(u3phy->dev, "u3\n");
++
++	return 0;
++}
++
++static int rockchip_u3phy_usb2_only_open(struct inode *inode,
++					 struct file *file)
++{
++	return single_open(file, rockchip_u3phy_usb2_only_show,
++			   inode->i_private);
++}
++
++static ssize_t rockchip_u3phy_usb2_only_write(struct file *file,
++					      const char __user *ubuf,
++					      size_t count, loff_t *ppos)
++{
++	struct seq_file			*s = file->private_data;
++	struct rockchip_u3phy		*u3phy = s->private;
++	struct rockchip_u3phy_port	*u3phy_port;
++	char				buf[32];
++	u8				index;
++
++	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
++		return -EFAULT;
++
++	if (!strncmp(buf, "u3", 2) &&
++	    param_exped(u3phy->u3phy_grf,
++			&u3phy->cfgs->grfcfg.u2_only_ctrl, 1)) {
++		dev_info(u3phy->dev, "Set usb3.0 and usb2.0 mode successfully\n");
++
++		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 0);
++
++		param_write(u3phy->grf,
++			    &u3phy->cfgs->grfcfg.u3_disable, false);
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.u2_only_ctrl, false);
++
++		for (index = 0; index < U3PHY_PORT_NUM; index++) {
++			u3phy_port = &u3phy->ports[index];
++			/* enable u3 rx termimation */
++			if (u3phy_port->type == U3PHY_TYPE_PIPE)
++				writel(0x30, u3phy_port->base + 0xd8);
++		}
++
++		atomic_notifier_call_chain(&u3phy->usb_phy.notifier, 0, NULL);
++
++		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 1);
++	} else if (!strncmp(buf, "u2", 2) &&
++		   param_exped(u3phy->u3phy_grf,
++			       &u3phy->cfgs->grfcfg.u2_only_ctrl, 0)) {
++		dev_info(u3phy->dev, "Set usb2.0 only mode successfully\n");
++
++		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 0);
++
++		param_write(u3phy->grf,
++			    &u3phy->cfgs->grfcfg.u3_disable, true);
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.u2_only_ctrl, true);
++
++		for (index = 0; index < U3PHY_PORT_NUM; index++) {
++			u3phy_port = &u3phy->ports[index];
++			/* disable u3 rx termimation */
++			if (u3phy_port->type == U3PHY_TYPE_PIPE)
++				writel(0x20, u3phy_port->base + 0xd8);
++		}
++
++		atomic_notifier_call_chain(&u3phy->usb_phy.notifier, 0, NULL);
++
++		gpiod_set_value_cansleep(u3phy->vbus_drv_gpio, 1);
++	} else {
++		dev_info(u3phy->dev, "Same or illegal mode\n");
++	}
++
++	return count;
++}
++
++static const struct file_operations rockchip_u3phy_usb2_only_fops = {
++	.open			= rockchip_u3phy_usb2_only_open,
++	.write			= rockchip_u3phy_usb2_only_write,
++	.read			= seq_read,
++	.llseek			= seq_lseek,
++	.release		= single_release,
++};
++
++int rockchip_u3phy_debugfs_init(struct rockchip_u3phy *u3phy)
++{
++	struct dentry		*root;
++	struct dentry		*file;
++	int			ret;
++
++	root = debugfs_create_dir(dev_name(u3phy->dev), NULL);
++	if (!root) {
++		ret = -ENOMEM;
++		goto err0;
++	}
++
++	u3phy->root = root;
++
++	file = debugfs_create_file("u3phy_mode", 0644, root,
++				   u3phy, &rockchip_u3phy_usb2_only_fops);
++	if (!file) {
++		ret = -ENOMEM;
++		goto err1;
++	}
++	return 0;
++
++err1:
++	debugfs_remove_recursive(root);
++err0:
++	return ret;
++}
++
++static const char *get_rest_name(enum rockchip_u3phy_rest_req rst)
++{
++	switch (rst) {
++	case U2_POR_RSTN:
++		return "u3phy-u2-por";
++	case U3_POR_RSTN:
++		return "u3phy-u3-por";
++	case PIPE_MAC_RSTN:
++		return "u3phy-pipe-mac";
++	case UTMI_MAC_RSTN:
++		return "u3phy-utmi-mac";
++	case UTMI_APB_RSTN:
++		return "u3phy-utmi-apb";
++	case PIPE_APB_RSTN:
++		return "u3phy-pipe-apb";
++	default:
++		return "invalid";
++	}
++}
++
++static void rockchip_u3phy_rest_deassert(struct rockchip_u3phy *u3phy,
++					 unsigned int flag)
++{
++	int rst;
++
++	if (flag & U3PHY_APB_RST) {
++		dev_dbg(u3phy->dev, "deassert APB bus interface reset\n");
++		for (rst = PIPE_APB_RSTN; rst <= UTMI_APB_RSTN; rst++) {
++			if (u3phy->rsts[rst])
++				reset_control_deassert(u3phy->rsts[rst]);
++		}
++	}
++
++	if (flag & U3PHY_POR_RST) {
++		usleep_range(12, 15);
++		dev_dbg(u3phy->dev, "deassert u2 and u3 phy power on reset\n");
++		for (rst = U3_POR_RSTN; rst <= U2_POR_RSTN; rst++) {
++			if (u3phy->rsts[rst])
++				reset_control_deassert(u3phy->rsts[rst]);
++		}
++	}
++
++	if (flag & U3PHY_MAC_RST) {
++		usleep_range(1200, 1500);
++		dev_dbg(u3phy->dev, "deassert pipe and utmi MAC reset\n");
++		for (rst = PIPE_MAC_RSTN; rst <= UTMI_MAC_RSTN; rst++)
++			if (u3phy->rsts[rst])
++				reset_control_deassert(u3phy->rsts[rst]);
++	}
++}
++
++static void rockchip_u3phy_rest_assert(struct rockchip_u3phy *u3phy)
++{
++	int rst;
++
++	dev_dbg(u3phy->dev, "assert u3phy reset\n");
++	for (rst = 0; rst < U3PHY_RESET_MAX; rst++)
++		if (u3phy->rsts[rst])
++			reset_control_assert(u3phy->rsts[rst]);
++}
++
++static int rockchip_u3phy_clk_enable(struct rockchip_u3phy *u3phy)
++{
++	int ret, clk;
++
++	for (clk = 0; clk < u3phy->num_clocks && u3phy->clks[clk]; clk++) {
++		ret = clk_prepare_enable(u3phy->clks[clk]);
++		if (ret)
++			goto err_disable_clks;
++	}
++	return 0;
++
++err_disable_clks:
++	while (--clk >= 0)
++		clk_disable_unprepare(u3phy->clks[clk]);
++	return ret;
++}
++
++static void rockchip_u3phy_clk_disable(struct rockchip_u3phy *u3phy)
++{
++	int clk;
++
++	for (clk = u3phy->num_clocks - 1; clk >= 0; clk--)
++		if (u3phy->clks[clk])
++			clk_disable_unprepare(u3phy->clks[clk]);
++}
++
++static int rockchip_u3phy_init(struct phy *phy)
++{
++	return 0;
++}
++
++static int rockchip_u3phy_exit(struct phy *phy)
++{
++	return 0;
++}
++
++static int rockchip_u3phy_power_on(struct phy *phy)
++{
++	struct rockchip_u3phy_port *u3phy_port = phy_get_drvdata(phy);
++	struct rockchip_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);
++	int ret;
++
++	dev_info(&u3phy_port->phy->dev, "u3phy %s power on\n",
++		 (u3phy_port->type == U3PHY_TYPE_UTMI) ? "u2" : "u3");
++
++	if (!u3phy_port->suspended)
++		return 0;
++
++	ret = rockchip_u3phy_clk_enable(u3phy);
++	if (ret)
++		return ret;
++
++	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.um_suspend, false);
++	} else {
++		/* current in p2 ? */
++		if (param_exped(u3phy->u3phy_grf,
++				&u3phy->cfgs->grfcfg.pp_pwr_st, PIPE_PWR_P2))
++			goto done;
++
++		if (u3phy->cfgs->phy_pipe_power) {
++			dev_dbg(u3phy->dev, "do pipe power up\n");
++			u3phy->cfgs->phy_pipe_power(u3phy, u3phy_port, true);
++		}
++
++		/* exit to p0 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P0], true);
++		usleep_range(90, 100);
++
++		/* enter to p2 from p0 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P2],
++			    false);
++		udelay(3);
++	}
++
++done:
++	u3phy_port->suspended = false;
++	return 0;
++}
++
++static int rockchip_u3phy_power_off(struct phy *phy)
++{
++	struct rockchip_u3phy_port *u3phy_port = phy_get_drvdata(phy);
++	struct rockchip_u3phy *u3phy = dev_get_drvdata(phy->dev.parent);
++
++	dev_info(&u3phy_port->phy->dev, "u3phy %s power off\n",
++		 (u3phy_port->type == U3PHY_TYPE_UTMI) ? "u2" : "u3");
++
++	if (u3phy_port->suspended)
++		return 0;
++
++	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.um_suspend, true);
++	} else {
++		/* current in p3 ? */
++		if (param_exped(u3phy->u3phy_grf,
++				&u3phy->cfgs->grfcfg.pp_pwr_st, PIPE_PWR_P3))
++			goto done;
++
++		/* exit to p0 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P0], true);
++		udelay(2);
++
++		/* enter to p3 from p0 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.pp_pwr_en[PIPE_PWR_P3], true);
++		udelay(6);
++
++		if (u3phy->cfgs->phy_pipe_power) {
++			dev_dbg(u3phy->dev, "do pipe power down\n");
++			u3phy->cfgs->phy_pipe_power(u3phy, u3phy_port, false);
++		}
++	}
++
++done:
++	rockchip_u3phy_clk_disable(u3phy);
++	u3phy_port->suspended = true;
++	return 0;
++}
++
++static __maybe_unused
++struct phy *rockchip_u3phy_xlate(struct device *dev,
++				 struct of_phandle_args *args)
++{
++	struct rockchip_u3phy *u3phy = dev_get_drvdata(dev);
++	struct rockchip_u3phy_port *u3phy_port = NULL;
++	struct device_node *phy_np = args->np;
++	int index;
++
++	if (args->args_count != 1) {
++		dev_err(dev, "invalid number of cells in 'phy' property\n");
++		return ERR_PTR(-EINVAL);
++	}
++
++	for (index = 0; index < U3PHY_PORT_NUM; index++) {
++		if (phy_np == u3phy->ports[index].phy->dev.of_node) {
++			u3phy_port = &u3phy->ports[index];
++			break;
++		}
++	}
++
++	if (!u3phy_port) {
++		dev_err(dev, "failed to find appropriate phy\n");
++		return ERR_PTR(-EINVAL);
++	}
++
++	return u3phy_port->phy;
++}
++
++static struct phy_ops rockchip_u3phy_ops = {
++	.init		= rockchip_u3phy_init,
++	.exit		= rockchip_u3phy_exit,
++	.power_on	= rockchip_u3phy_power_on,
++	.power_off	= rockchip_u3phy_power_off,
++	.owner		= THIS_MODULE,
++};
++
++/*
++ * The function manage host-phy port state and suspend/resume phy port
++ * to save power automatically.
++ *
++ * we rely on utmi_linestate and utmi_hostdisconnect to identify whether
++ * devices is disconnect or not. Besides, we do not need care it is FS/LS
++ * disconnected or HS disconnected, actually, we just only need get the
++ * device is disconnected at last through rearm the delayed work,
++ * to suspend the phy port in _PHY_STATE_DISCONNECT_ case.
++ */
++static void rockchip_u3phy_um_sm_work(struct work_struct *work)
++{
++	struct rockchip_u3phy_port *u3phy_port =
++		container_of(work, struct rockchip_u3phy_port, um_sm_work.work);
++	struct rockchip_u3phy *u3phy =
++		dev_get_drvdata(u3phy_port->phy->dev.parent);
++	unsigned int sh = u3phy->cfgs->grfcfg.um_hstdct.bitend -
++			u3phy->cfgs->grfcfg.um_hstdct.bitstart + 1;
++	unsigned int ul, uhd, state;
++	unsigned int ul_mask, uhd_mask;
++	int ret;
++
++	mutex_lock(&u3phy_port->mutex);
++
++	ret = regmap_read(u3phy->u3phy_grf,
++			  u3phy->cfgs->grfcfg.um_ls.offset, &ul);
++	if (ret < 0)
++		goto next_schedule;
++
++	ret = regmap_read(u3phy->u3phy_grf,
++			  u3phy->cfgs->grfcfg.um_hstdct.offset, &uhd);
++	if (ret < 0)
++		goto next_schedule;
++
++	uhd_mask = GENMASK(u3phy->cfgs->grfcfg.um_hstdct.bitend,
++			   u3phy->cfgs->grfcfg.um_hstdct.bitstart);
++	ul_mask = GENMASK(u3phy->cfgs->grfcfg.um_ls.bitend,
++			  u3phy->cfgs->grfcfg.um_ls.bitstart);
++
++	/* stitch on um_ls and um_hstdct as phy state */
++	state = ((uhd & uhd_mask) >> u3phy->cfgs->grfcfg.um_hstdct.bitstart) |
++		(((ul & ul_mask) >> u3phy->cfgs->grfcfg.um_ls.bitstart) << sh);
++
++	switch (state) {
++	case PHY_UTMI_HS_ONLINE:
++		dev_dbg(&u3phy_port->phy->dev, "HS online\n");
++		break;
++	case PHY_UTMI_FS_LS_ONLINE:
++		/*
++		 * For FS/LS device, the online state share with connect state
++		 * from um_ls and um_hstdct register, so we distinguish
++		 * them via suspended flag.
++		 *
++		 * Plus, there are two cases, one is D- Line pull-up, and D+
++		 * line pull-down, the state is 4; another is D+ line pull-up,
++		 * and D- line pull-down, the state is 2.
++		 */
++		if (!u3phy_port->suspended) {
++			/* D- line pull-up, D+ line pull-down */
++			dev_dbg(&u3phy_port->phy->dev, "FS/LS online\n");
++			break;
++		}
++		/* fall through */
++	case PHY_UTMI_CONNECT:
++		if (u3phy_port->suspended) {
++			dev_dbg(&u3phy_port->phy->dev, "Connected\n");
++			rockchip_u3phy_power_on(u3phy_port->phy);
++			u3phy_port->suspended = false;
++		} else {
++			/* D+ line pull-up, D- line pull-down */
++			dev_dbg(&u3phy_port->phy->dev, "FS/LS online\n");
++		}
++		break;
++	case PHY_UTMI_DISCONNECT:
++		if (!u3phy_port->suspended) {
++			dev_dbg(&u3phy_port->phy->dev, "Disconnected\n");
++			rockchip_u3phy_power_off(u3phy_port->phy);
++			u3phy_port->suspended = true;
++		}
++
++		/*
++		 * activate the linestate detection to get the next device
++		 * plug-in irq.
++		 */
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.ls_det_st, true);
++		param_write(u3phy->u3phy_grf,
++			    &u3phy->cfgs->grfcfg.ls_det_en, true);
++
++		/*
++		 * we don't need to rearm the delayed work when the phy port
++		 * is suspended.
++		 */
++		mutex_unlock(&u3phy_port->mutex);
++		return;
++	default:
++		dev_dbg(&u3phy_port->phy->dev, "unknown phy state\n");
++		break;
++	}
++
++next_schedule:
++	mutex_unlock(&u3phy_port->mutex);
++	schedule_delayed_work(&u3phy_port->um_sm_work, SCHEDULE_DELAY);
++}
++
++static irqreturn_t rockchip_u3phy_um_ls_irq(int irq, void *data)
++{
++	struct rockchip_u3phy_port *u3phy_port = data;
++	struct rockchip_u3phy *u3phy =
++		dev_get_drvdata(u3phy_port->phy->dev.parent);
++
++	if (!param_exped(u3phy->u3phy_grf,
++			 &u3phy->cfgs->grfcfg.ls_det_st,
++			 u3phy->cfgs->grfcfg.ls_det_st.dvalue))
++		return IRQ_NONE;
++
++	dev_dbg(u3phy->dev, "utmi linestate interrupt\n");
++	mutex_lock(&u3phy_port->mutex);
++
++	/* disable linestate detect irq and clear its status */
++	param_write(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.ls_det_en, false);
++	param_write(u3phy->u3phy_grf, &u3phy->cfgs->grfcfg.ls_det_st, true);
++
++	mutex_unlock(&u3phy_port->mutex);
++
++	/*
++	 * In this case for host phy, a new device is plugged in, meanwhile,
++	 * if the phy port is suspended, we need rearm the work to resume it
++	 * and mange its states; otherwise, we just return irq handled.
++	 */
++	if (u3phy_port->suspended) {
++		dev_dbg(u3phy->dev, "schedule utmi sm work\n");
++		rockchip_u3phy_um_sm_work(&u3phy_port->um_sm_work.work);
++	}
++
++	return IRQ_HANDLED;
++}
++
++static int rockchip_u3phy_parse_dt(struct rockchip_u3phy *u3phy,
++				   struct platform_device *pdev)
++
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++	int ret, i, clk;
++
++	u3phy->um_ls_irq = platform_get_irq_byname(pdev, "linestate");
++	if (u3phy->um_ls_irq < 0) {
++		dev_err(dev, "get utmi linestate irq failed\n");
++		return -ENXIO;
++	}
++
++	u3phy->vbus_drv_gpio = devm_gpiod_get_optional(dev, "vbus-drv",
++						       GPIOD_OUT_HIGH);
++
++	if (!u3phy->vbus_drv_gpio) {
++		dev_warn(&pdev->dev, "vbus_drv is not assigned\n");
++	} else if (IS_ERR(u3phy->vbus_drv_gpio)) {
++		dev_err(&pdev->dev, "failed to get vbus_drv\n");
++		return PTR_ERR(u3phy->vbus_drv_gpio);
++	}
++
++	u3phy->num_clocks = of_clk_get_parent_count(np);
++	if (u3phy->num_clocks == 0)
++		dev_warn(&pdev->dev, "no clks found in dt\n");
++
++	u3phy->clks = devm_kcalloc(dev, u3phy->num_clocks,
++				  sizeof(struct clk *), GFP_KERNEL);
++
++	for (clk = 0; clk < u3phy->num_clocks; clk++) {
++		u3phy->clks[clk] = of_clk_get(np, clk);
++		if (IS_ERR(u3phy->clks[clk])) {
++			ret = PTR_ERR(u3phy->clks[clk]);
++			if (ret == -EPROBE_DEFER)
++				goto err_put_clks;
++			dev_err(&pdev->dev, "failed to get clks, %i\n",
++				ret);
++			u3phy->clks[clk] = NULL;
++			break;
++		}
++	}
++
++	for (i = 0; i < U3PHY_RESET_MAX; i++) {
++		u3phy->rsts[i] = devm_reset_control_get(dev, get_rest_name(i));
++		if (IS_ERR(u3phy->rsts[i])) {
++			dev_info(dev, "no %s reset control specified\n",
++				 get_rest_name(i));
++			u3phy->rsts[i] = NULL;
++		}
++	}
++
++	return 0;
++
++err_put_clks:
++	while (--clk >= 0)
++		clk_put(u3phy->clks[clk]);
++	return ret;
++}
++
++static int rockchip_u3phy_port_init(struct rockchip_u3phy *u3phy,
++				    struct rockchip_u3phy_port *u3phy_port,
++				    struct device_node *child_np)
++{
++	struct resource res;
++	struct phy *phy;
++	int ret;
++
++	dev_dbg(u3phy->dev, "u3phy port initialize\n");
++
++	mutex_init(&u3phy_port->mutex);
++	u3phy_port->suspended = true; /* initial status */
++
++	phy = devm_phy_create(u3phy->dev, child_np, &rockchip_u3phy_ops);
++	if (IS_ERR(phy)) {
++		dev_err(u3phy->dev, "failed to create phy\n");
++		return PTR_ERR(phy);
++	}
++
++	u3phy_port->phy = phy;
++
++	ret = of_address_to_resource(child_np, 0, &res);
++	if (ret) {
++		dev_err(u3phy->dev, "failed to get address resource(np-%s)\n",
++			child_np->name);
++		return ret;
++	}
++
++	u3phy_port->base = devm_ioremap_resource(&u3phy_port->phy->dev, &res);
++	if (IS_ERR(u3phy_port->base)) {
++		dev_err(u3phy->dev, "failed to remap phy regs\n");
++		return PTR_ERR(u3phy_port->base);
++	}
++
++	if (!of_node_cmp(child_np->name, "pipe")) {
++		u3phy_port->type = U3PHY_TYPE_PIPE;
++		u3phy_port->refclk_25m_quirk =
++			of_property_read_bool(child_np,
++					      "rockchip,refclk-25m-quirk");
++	} else {
++		u3phy_port->type = U3PHY_TYPE_UTMI;
++		INIT_DELAYED_WORK(&u3phy_port->um_sm_work,
++				  rockchip_u3phy_um_sm_work);
++
++		ret = devm_request_threaded_irq(u3phy->dev, u3phy->um_ls_irq,
++						NULL, rockchip_u3phy_um_ls_irq,
++						IRQF_ONESHOT, "rockchip_u3phy",
++						u3phy_port);
++		if (ret) {
++			dev_err(u3phy->dev, "failed to request utmi linestate irq handle\n");
++			return ret;
++		}
++	}
++
++	if (u3phy->cfgs->phy_tuning) {
++		dev_dbg(u3phy->dev, "do u3phy tuning\n");
++		ret = u3phy->cfgs->phy_tuning(u3phy, u3phy_port, child_np);
++		if (ret)
++			return ret;
++	}
++
++	phy_set_drvdata(u3phy_port->phy, u3phy_port);
++	return 0;
++}
++
++static int rockchip_u3phy_on_init(struct usb_phy *usb_phy)
++{
++	struct rockchip_u3phy *u3phy =
++		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
++
++	rockchip_u3phy_rest_deassert(u3phy, U3PHY_POR_RST | U3PHY_MAC_RST);
++	return 0;
++}
++
++static void rockchip_u3phy_on_shutdown(struct usb_phy *usb_phy)
++{
++	struct rockchip_u3phy *u3phy =
++		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
++	int rst;
++
++	for (rst = 0; rst < U3PHY_RESET_MAX; rst++)
++		if (u3phy->rsts[rst] && rst != UTMI_APB_RSTN &&
++		    rst != PIPE_APB_RSTN)
++			reset_control_assert(u3phy->rsts[rst]);
++	udelay(1);
++}
++
++static int rockchip_u3phy_on_disconnect(struct usb_phy *usb_phy,
++					enum usb_device_speed speed)
++{
++	struct rockchip_u3phy *u3phy =
++		container_of(usb_phy, struct rockchip_u3phy, usb_phy);
++
++	dev_info(u3phy->dev, "%s device has disconnected\n",
++		 (speed == USB_SPEED_SUPER) ? "U3" : "UW/U2/U1.1/U1");
++
++	if (speed == USB_SPEED_SUPER)
++		atomic_notifier_call_chain(&usb_phy->notifier, 0, NULL);
++
++	return 0;
++}
++
++static int rockchip_u3phy_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = dev->of_node;
++	struct device_node *child_np;
++	struct phy_provider *provider;
++	struct rockchip_u3phy *u3phy;
++	const struct rockchip_u3phy_cfg *phy_cfgs;
++	const struct of_device_id *match;
++	unsigned int reg[2];
++	int index, ret;
++
++	match = of_match_device(dev->driver->of_match_table, dev);
++	if (!match || !match->data) {
++		dev_err(dev, "phy-cfgs are not assigned!\n");
++		return -EINVAL;
++	}
++
++	u3phy = devm_kzalloc(dev, sizeof(*u3phy), GFP_KERNEL);
++	if (!u3phy)
++		return -ENOMEM;
++
++	u3phy->u3phy_grf =
++		syscon_regmap_lookup_by_phandle(np, "rockchip,u3phygrf");
++	if (IS_ERR(u3phy->u3phy_grf))
++		return PTR_ERR(u3phy->u3phy_grf);
++
++	u3phy->grf =
++		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
++	if (IS_ERR(u3phy->grf)) {
++		dev_err(dev, "Missing rockchip,grf property\n");
++		return PTR_ERR(u3phy->grf);
++	}
++
++	if (of_property_read_u32_array(np, "reg", reg, 2)) {
++		dev_err(dev, "the reg property is not assigned in %s node\n",
++			np->name);
++		return -EINVAL;
++	}
++
++	u3phy->dev = dev;
++	phy_cfgs = match->data;
++	platform_set_drvdata(pdev, u3phy);
++
++	/* find out a proper config which can be matched with dt. */
++	index = 0;
++	while (phy_cfgs[index].reg) {
++		if (phy_cfgs[index].reg == reg[1]) {
++			u3phy->cfgs = &phy_cfgs[index];
++			break;
++		}
++
++		++index;
++	}
++
++	if (!u3phy->cfgs) {
++		dev_err(dev, "no phy-cfgs can be matched with %s node\n",
++			np->name);
++		return -EINVAL;
++	}
++
++	ret = rockchip_u3phy_parse_dt(u3phy, pdev);
++	if (ret) {
++		dev_err(dev, "parse dt failed, ret(%d)\n", ret);
++		return ret;
++	}
++
++	ret = rockchip_u3phy_clk_enable(u3phy);
++	if (ret) {
++		dev_err(dev, "clk enable failed, ret(%d)\n", ret);
++		return ret;
++	}
++
++	rockchip_u3phy_rest_assert(u3phy);
++	rockchip_u3phy_rest_deassert(u3phy, U3PHY_APB_RST | U3PHY_POR_RST);
++
++	index = 0;
++	for_each_available_child_of_node(np, child_np) {
++		struct rockchip_u3phy_port *u3phy_port = &u3phy->ports[index];
++
++		u3phy_port->index = index;
++		ret = rockchip_u3phy_port_init(u3phy, u3phy_port, child_np);
++		if (ret) {
++			dev_err(dev, "u3phy port init failed,ret(%d)\n", ret);
++			goto put_child;
++		}
++
++		/* to prevent out of boundary */
++		if (++index >= U3PHY_PORT_NUM)
++			break;
++	}
++
++	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
++	if (IS_ERR_OR_NULL(provider))
++		goto put_child;
++
++	rockchip_u3phy_rest_deassert(u3phy, U3PHY_MAC_RST);
++	rockchip_u3phy_clk_disable(u3phy);
++
++	u3phy->usb_phy.dev = dev;
++	u3phy->usb_phy.init = rockchip_u3phy_on_init;
++	u3phy->usb_phy.shutdown = rockchip_u3phy_on_shutdown;
++	u3phy->usb_phy.notify_disconnect = rockchip_u3phy_on_disconnect;
++	usb_add_phy(&u3phy->usb_phy, USB_PHY_TYPE_USB3);
++	ATOMIC_INIT_NOTIFIER_HEAD(&u3phy->usb_phy.notifier);
++
++	rockchip_u3phy_debugfs_init(u3phy);
++
++	dev_info(dev, "Rockchip u3phy initialized successfully\n");
++	return 0;
++
++put_child:
++	of_node_put(child_np);
++	return ret;
++}
++
++static int rk3328_u3phy_pipe_power(struct rockchip_u3phy *u3phy,
++				   struct rockchip_u3phy_port *u3phy_port,
++				   bool on)
++{
++	unsigned int reg;
++
++	if (on) {
++		reg = readl(u3phy_port->base + 0x1a8);
++		reg &= ~BIT(4); /* ldo power up */
++		writel(reg, u3phy_port->base + 0x1a8);
++
++		reg = readl(u3phy_port->base + 0x044);
++		reg &= ~BIT(4); /* bg power on */
++		writel(reg, u3phy_port->base + 0x044);
++
++		reg = readl(u3phy_port->base + 0x150);
++		reg |= BIT(6); /* tx bias enable */
++		writel(reg, u3phy_port->base + 0x150);
++
++		reg = readl(u3phy_port->base + 0x080);
++		reg &= ~BIT(2); /* tx cm power up */
++		writel(reg, u3phy_port->base + 0x080);
++
++		reg = readl(u3phy_port->base + 0x0c0);
++		/* tx obs enable and rx cm enable */
++		reg |= (BIT(3) | BIT(4));
++		writel(reg, u3phy_port->base + 0x0c0);
++
++		udelay(1);
++	} else {
++		reg = readl(u3phy_port->base + 0x1a8);
++		reg |= BIT(4); /* ldo power down */
++		writel(reg, u3phy_port->base + 0x1a8);
++
++		reg = readl(u3phy_port->base + 0x044);
++		reg |= BIT(4); /* bg power down */
++		writel(reg, u3phy_port->base + 0x044);
++
++		reg = readl(u3phy_port->base + 0x150);
++		reg &= ~BIT(6); /* tx bias disable */
++		writel(reg, u3phy_port->base + 0x150);
++
++		reg = readl(u3phy_port->base + 0x080);
++		reg |= BIT(2); /* tx cm power down */
++		writel(reg, u3phy_port->base + 0x080);
++
++		reg = readl(u3phy_port->base + 0x0c0);
++		/* tx obs disable and rx cm disable */
++		reg &= ~(BIT(3) | BIT(4));
++		writel(reg, u3phy_port->base + 0x0c0);
++	}
++
++	return 0;
++}
++
++static int rk3328_u3phy_tuning(struct rockchip_u3phy *u3phy,
++			       struct rockchip_u3phy_port *u3phy_port,
++			       struct device_node *child_np)
++{
++	if (u3phy_port->type == U3PHY_TYPE_UTMI) {
++		/*
++		 * For rk3328 SoC, pre-emphasis and pre-emphasis strength must
++		 * be written as one fixed value as below.
++		 *
++		 * Dissimilarly, the odt 45ohm value should be flexibly tuninged
++		 * for the different boards to adjust HS eye height, so its
++		 * value can be assigned in DT in code design.
++		 */
++
++		/* {bits[2:0]=111}: always enable pre-emphasis */
++		u3phy->apbcfg.u2_pre_emp = 0x0f;
++
++		/* {bits[5:3]=000}: pre-emphasis strength as the weakest */
++		u3phy->apbcfg.u2_pre_emp_sth = 0x41;
++
++		/* {bits[4:0]=10101}: odt 45ohm tuning */
++		u3phy->apbcfg.u2_odt_tuning = 0xb5;
++		/* optional override of the odt 45ohm tuning */
++		of_property_read_u32(child_np, "rockchip,odt-val-tuning",
++				     &u3phy->apbcfg.u2_odt_tuning);
++
++		writel(u3phy->apbcfg.u2_pre_emp, u3phy_port->base + 0x030);
++		writel(u3phy->apbcfg.u2_pre_emp_sth, u3phy_port->base + 0x040);
++		writel(u3phy->apbcfg.u2_odt_tuning, u3phy_port->base + 0x11c);
++	} else if (u3phy_port->type == U3PHY_TYPE_PIPE) {
++		if (u3phy_port->refclk_25m_quirk) {
++			dev_dbg(u3phy->dev, "switch to 25m refclk\n");
++			/* ref clk switch to 25M */
++			writel(0x64, u3phy_port->base + 0x11c);
++			writel(0x64, u3phy_port->base + 0x028);
++			writel(0x01, u3phy_port->base + 0x020);
++			writel(0x21, u3phy_port->base + 0x030);
++			writel(0x06, u3phy_port->base + 0x108);
++			writel(0x00, u3phy_port->base + 0x118);
++		} else {
++			/* configure for 24M ref clk */
++			writel(0x80, u3phy_port->base + 0x10c);
++			writel(0x01, u3phy_port->base + 0x118);
++			writel(0x38, u3phy_port->base + 0x11c);
++			writel(0x83, u3phy_port->base + 0x020);
++			writel(0x02, u3phy_port->base + 0x108);
++		}
++
++		/* Enable SSC */
++		udelay(3);
++		writel(0x08, u3phy_port->base + 0x000);
++		writel(0x0c, u3phy_port->base + 0x120);
++
++		/* Tuning Rx for compliance RJTL test */
++		writel(0x70, u3phy_port->base + 0x150);
++		writel(0x12, u3phy_port->base + 0x0c8);
++		writel(0x05, u3phy_port->base + 0x148);
++		writel(0x08, u3phy_port->base + 0x068);
++		writel(0xf0, u3phy_port->base + 0x1c4);
++		writel(0xff, u3phy_port->base + 0x070);
++		writel(0x0f, u3phy_port->base + 0x06c);
++		writel(0xe0, u3phy_port->base + 0x060);
++
++		/*
++		 * Tuning Tx to increase the bias current
++		 * used in TX driver and RX EQ, it can
++		 * also increase the voltage of LFPS.
++		 */
++		writel(0x08, u3phy_port->base + 0x180);
++	} else {
++		dev_err(u3phy->dev, "invalid u3phy port type\n");
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static const struct rockchip_u3phy_cfg rk3328_u3phy_cfgs[] = {
++	{
++		.reg		= 0xff470000,
++		.grfcfg		= {
++			.um_suspend	= { 0x0004, 15, 0, 0x1452, 0x15d1 },
++			.u2_only_ctrl	= { 0x0020, 15, 15, 0, 1 },
++			.um_ls		= { 0x0030, 5, 4, 0, 1 },
++			.um_hstdct	= { 0x0030, 7, 7, 0, 1 },
++			.ls_det_en	= { 0x0040, 0, 0, 0, 1 },
++			.ls_det_st	= { 0x0044, 0, 0, 0, 1 },
++			.pp_pwr_st	= { 0x0034, 14, 13, 0, 0},
++			.pp_pwr_en	= { {0x0020, 14, 0, 0x0014, 0x0005},
++					    {0x0020, 14, 0, 0x0014, 0x000d},
++					    {0x0020, 14, 0, 0x0014, 0x0015},
++					    {0x0020, 14, 0, 0x0014, 0x001d} },
++			.u3_disable	= { 0x04c4, 15, 0, 0x1100, 0x101},
++		},
++		.phy_pipe_power	= rk3328_u3phy_pipe_power,
++		.phy_tuning	= rk3328_u3phy_tuning,
++	},
++	{ /* sentinel */ }
++};
++
++static const struct of_device_id rockchip_u3phy_dt_match[] = {
++	{ .compatible = "rockchip,rk3328-u3phy", .data = &rk3328_u3phy_cfgs },
++	{}
++};
++MODULE_DEVICE_TABLE(of, rockchip_u3phy_dt_match);
++
++static struct platform_driver rockchip_u3phy_driver = {
++	.probe		= rockchip_u3phy_probe,
++	.driver		= {
++		.name	= "rockchip-u3phy",
++		.of_match_table = rockchip_u3phy_dt_match,
++	},
++};
++module_platform_driver(rockchip_u3phy_driver);
++
++MODULE_AUTHOR("Frank Wang <frank.wang@rock-chips.com>");
++MODULE_AUTHOR("William Wu <william.wu@rock-chips.com>");
++MODULE_DESCRIPTION("Rockchip USB 3.0 PHY driver");
++MODULE_LICENSE("GPL v2");
+
+diff --git a/Documentation/devicetree/bindings/phy/phy-rockchip-inno-usb3.yaml b/Documentation/devicetree/bindings/phy/phy-rockchip-inno-usb3.yaml
+new file mode 100644
+index 000000000000..f4f28625173a
+--- /dev/null
++++ b/Documentation/devicetree/bindings/phy/phy-rockchip-inno-usb3.yaml
+@@ -0,0 +1,157 @@
++# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: "http://devicetree.org/schemas/phy/phy-rockchip-inno-usb3.yaml#"
++$schema: "http://devicetree.org/meta-schemas/core.yaml#"
++
++title: ROCKCHIP USB 3.0 PHY WITH INNO IP BLOCK
++
++maintainers:
++
++properties:
++  compatible:
++    enum:
++      - rockchip,rk3328-u3phy
++
++  reg:
++    - description: the base address of the USB 3.0 PHY
++
++  interrupts:
++    maxItems: 1
++
++  interrupt-names:
++    items:
++      - const: linestate
++        description: host/otg linestate interrupt
++
++  clocks:
++    maxItems: 2
++
++  clock-names:
++    items:
++      - const: u3phy-otg
++        description: USB 3.0 PHY UTMI
++      - const: u3phy-pipe
++        description: USB 3.0 PHY Pipe
++
++  resets:
++    maxItems: 6
++
++  reset-names:
++    items:
++      - const: u3phy-u2-por
++      description: USB 2.0 logic of USB 3.0 PHY
++      - const: u3phy-u3-por
++      description: USB 3.0 logic of USB 3.0 PHY
++      - const: u3phy-pipe-mac
++      description: USB 3.0 PHY pipe MAC
++      - const: u3phy-utmi-mac
++      description: USB 3.0 PHY utmi MAC
++      - const: u3phy-utmi-apb
++      description: USB 3.0 PHY utmi apb
++      - const: u3phy-pipe-apb
++      description: USB 3.0 PHY pipe apb
++
++  "#phy-cells":
++    const: 1
++
++  rockchip,u3phygrf:
++    $ref: /schemas/types.yaml#/definitions/phandle-array
++    type: array
++    - description: phandle to the syscon managing the
++                   "USB 3.0 PHY general register files".
++
++  vbus-drv-gpios:
++    $ref: /schemas/types.yaml#/definitions/phandle-array
++    type: array
++    - description: phandle for gpio vbus supply
++
++required:
++  - compatible
++  - reg
++  - interrupts
++  - interrupt-names
++  - clocks
++  - clock-names
++  - resets
++  - reset-names
++  - "#phy-cells"
++  - rockchip,u3phygrf
++
++patternProperties:
++  "^u3phy_utmi@[0-9a-f]+$":
++    type: object
++
++    properties:
++      - description: USB 2.0 utmi phy.
++
++      rockchip,odt-val-tuning:
++        type: boolean
++        - description: specify 45ohm ODT tuning value.
++
++      "phy-cells":
++        const: 0
++
++    required:
++      - reg
++      - "#phy-cells"
++
++patternProperties:
++  "^u3phy_pipe@[0-9a-f]+$":
++    type: object
++
++    properties:
++      - description: USB 3.0 pipe phy.
++
++      rockchip,refclk-25m-quirk :
++
++        - description: phy reference clock changed to 25m quirk.
++
++      "phy-cells":
++        const: 0
++
++    required:
++      - reg
++      - "#phy-cells"
++
++examples:
++
++usb3phy_grf: syscon@ff460000 {
++	compatible = "rockchip,usb3phy-grf", "syscon";
++	reg = <0x0 0xff460000 0x0 0x1000>;
++};
++
++...
++
++u3phy: usb3-phy@ff470000 {
++	compatible = "rockchip,rk3328-u3phy";
++	reg = <0x0 0xff470000 0x0 0x0>;
++	rockchip,u3phygrf = <&usb3phy_grf>;
++	interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
++	interrupt-names = "linestate";
++	clocks = <&cru PCLK_USB3PHY_OTG>, <&cru PCLK_USB3PHY_PIPE>;
++	clock-names = "u3phy-otg", "u3phy-pipe";
++	resets = <&cru SRST_USB3PHY_U2>,
++		 <&cru SRST_USB3PHY_U3>,
++		 <&cru SRST_USB3PHY_PIPE>,
++		 <&cru SRST_USB3OTG_UTMI>,
++		 <&cru SRST_USB3PHY_OTG_P>,
++		 <&cru SRST_USB3PHY_PIPE_P>;
++	reset-names = "u3phy-u2-por", "u3phy-u3-por",
++		      "u3phy-pipe-mac", "u3phy-utmi-mac",
++		      "u3phy-utmi-apb", "u3phy-pipe-apb";
++	vbus-drv-gpios = <&gpio0 0 GPIO_ACTIVE_HIGH>;
++	#address-cells = <2>;
++	#size-cells = <2>;
++	ranges;
++
++	u3phy_utmi: utmi@ff470000 {
++		reg = <0x0 0xff470000 0x0 0x8000>;
++		#phy-cells = <0>;
++	};
++
++	u3phy_pipe: pipe@ff478000 {
++		reg = <0x0 0xff478000 0x0 0x8000>;
++		#phy-cells = <0>;
++	};
++};
+diff --git a/Documentation/devicetree/bindings/soc/rockchip/grf.txt b/Documentation/devicetree/bindings/soc/rockchip/grf.txt
+index ada5435ce2c3..5f2f19344cc7 100644
+--- a/Documentation/devicetree/bindings/soc/rockchip/grf.txt
++++ b/Documentation/devicetree/bindings/soc/rockchip/grf.txt
+@@ -34,6 +34,8 @@ Required Properties:
+    - "rockchip,rk3328-usb2phy-grf", "syscon": for rk3328
+ - compatible: USBGRF should be one of the following:
+    - "rockchip,rv1108-usbgrf", "syscon": for rv1108
++- compatible: USB3PHYGRF should be one of the following:
++   - "rockchip,u3phy-grf", "syscon"
+ - reg: physical base address of the controller and length of memory mapped
+   region.
+ 
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+index 31cc1541f1f5..072e988ad655 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -805,6 +805,47 @@
+ 		};
+ 	};
+ 
++	usb3phy_grf: syscon@ff460000 {
++		compatible = "rockchip,usb3phy-grf", "syscon";
++		reg = <0x0 0xff460000 0x0 0x1000>;
++	};
++
++	u3phy: usb3-phy@ff470000 {
++		compatible = "rockchip,rk3328-u3phy";
++		reg = <0x0 0xff470000 0x0 0x0>;
++		rockchip,u3phygrf = <&usb3phy_grf>;
++		rockchip,grf = <&grf>;
++		interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
++		interrupt-names = "linestate";
++		clocks = <&cru PCLK_USB3PHY_OTG>, <&cru PCLK_USB3PHY_PIPE>;
++		clock-names = "u3phy-otg", "u3phy-pipe";
++		resets = <&cru SRST_USB3PHY_U2>,
++			 <&cru SRST_USB3PHY_U3>,
++			 <&cru SRST_USB3PHY_PIPE>,
++			 <&cru SRST_USB3OTG_UTMI>,
++			 <&cru SRST_USB3PHY_OTG_P>,
++			 <&cru SRST_USB3PHY_PIPE_P>;
++		reset-names = "u3phy-u2-por", "u3phy-u3-por",
++			      "u3phy-pipe-mac", "u3phy-utmi-mac",
++			      "u3phy-utmi-apb", "u3phy-pipe-apb";
++		#address-cells = <2>;
++		#size-cells = <2>;
++		ranges;
++		status = "disabled";
++
++		u3phy_utmi: utmi@ff470000 {
++			reg = <0x0 0xff470000 0x0 0x8000>;
++			#phy-cells = <0>;
++			status = "disabled";
++		};
++
++		u3phy_pipe: pipe@ff478000 {
++			reg = <0x0 0xff478000 0x0 0x8000>;
++			#phy-cells = <0>;
++			status = "disabled";
++		};
++	};
++
+ 	sdmmc: dwmmc@ff500000 {
+ 		compatible = "rockchip,rk3328-dw-mshc", "rockchip,rk3288-dw-mshc";
+ 		reg = <0x0 0xff500000 0x0 0x4000>;
+@@ -936,6 +977,37 @@
+ 		status = "disabled";
+ 	};
+ 
++	usbdrd3: usb@ff600000 {
++		compatible = "rockchip,rk3328-dwc3", "rockchip,rk3399-dwc3";
++		clocks = <&cru SCLK_USB3OTG_REF>, <&cru ACLK_USB3OTG>,
++			 <&cru SCLK_USB3OTG_SUSPEND>;
++		clock-names = "ref", "bus_early",
++			      "suspend";
++		#address-cells = <2>;
++		#size-cells = <2>;
++		ranges;
++		clock-ranges;
++		status = "disabled";
++
++		usbdrd_dwc3: dwc3@ff600000 {
++			compatible = "snps,dwc3";
++			reg = <0x0 0xff600000 0x0 0x100000>;
++			interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
++			dr_mode = "otg";
++			phys = <&u3phy_utmi>, <&u3phy_pipe>;
++			phy-names = "usb2-phy", "usb3-phy";
++			phy_type = "utmi_wide";
++			snps,dis_enblslpm_quirk;
++			snps,dis-u2-freeclk-exists-quirk;
++			snps,dis_u2_susphy_quirk;
++			snps,dis_u3_susphy_quirk;
++			snps,dis-del-phy-power-chg-quirk;
++			snps,dis-tx-ipgap-linecheck-quirk;
++			snps,xhci-trb-ent-quirk;
++			status = "disabled";
++		};
++	};
++
+ 	gic: interrupt-controller@ff811000 {
+ 		compatible = "arm,gic-400";
+ 		#interrupt-cells = <3>;
+
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts b/arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts
+index bb40c163b05d..f300f3d0f02e 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts
++++ b/arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts
+@@ -328,6 +328,18 @@
+ 	status = "okay";
+ };
+ 
++&u3phy {
++	status = "okay";
++};
++
++&u3phy_utmi {
++	status = "okay";
++};
++
++&u3phy_pipe {
++	status = "okay";
++};
++
+ &uart2 {
+ 	status = "okay";
+ };
+@@ -344,6 +356,15 @@
+ 	status = "okay";
+ };
+ 
++&usbdrd3 {
++	status = "okay";
++};
++
++&usbdrd_dwc3 {
++	dr_mode = "host";
++	status = "okay";
++};
++
+ &vop {
+ 	status = "okay";
+ };
+
+diff --git a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
+index 62936b432..f97446924 100644
+--- a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
++++ b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
+@@ -383,6 +383,18 @@
+ 	status = "okay";
+ };
+ 
++&u3phy {
++	status = "okay";
++};
++
++&u3phy_utmi {
++	status = "okay";
++};
++
++&u3phy_pipe {
++	status = "okay";
++};
++
+ &usb_host0_ehci {
+ 	status = "okay";
+ };
+@@ -391,6 +403,15 @@
+ 	status = "okay";
+ };
+ 
++&usbdrd3 {
++	status = "okay";
++};
++
++&usbdrd_dwc3 {
++	dr_mode = "host";
++	status = "okay";
++};
++
+ &vop {
+ 	status = "okay";
+ };
diff --git a/target/linux/rockchip/patches-5.4/rk3328-add-dmc-driver.patch b/target/linux/rockchip/patches-5.4/rk3328-add-dmc-driver.patch
new file mode 100644
index 0000000000..761429289f
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/rk3328-add-dmc-driver.patch
@@ -0,0 +1,1796 @@
+From fcd9629c05f373771e85920e1c1d0ab252617878 Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 13:53:25 +0800
+Subject: [PATCH] PM / devfreq: rockchip: add devfreq driver for rk3328 dmc
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/devfreq/Kconfig      |  18 +-
+ drivers/devfreq/Makefile     |   1 +
+ drivers/devfreq/rk3328_dmc.c | 846 +++++++++++++++++++++++++++++++++++
+ 3 files changed, 862 insertions(+), 3 deletions(-)
+ create mode 100644 drivers/devfreq/rk3328_dmc.c
+
+diff --git a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
+index defe1d438710..5ae0832f046b 100644
+--- a/drivers/devfreq/Kconfig
++++ b/drivers/devfreq/Kconfig
+@@ -115,6 +115,18 @@ config ARM_TEGRA20_DEVFREQ
+ 	  It reads Memory Controller counters and adjusts the operating
+ 	  frequencies and voltages with OPP support.
+ 
++config ARM_RK3328_DMC_DEVFREQ
++	tristate "ARM RK3328 DMC DEVFREQ Driver"
++	depends on ARCH_ROCKCHIP
++	select DEVFREQ_EVENT_ROCKCHIP_DFI
++	select DEVFREQ_GOV_SIMPLE_ONDEMAND
++	select PM_DEVFREQ_EVENT
++	select PM_OPP
++	help
++	  This adds the DEVFREQ driver for the RK3328 DMC(Dynamic Memory Controller).
++	  It sets the frequency for the memory controller and reads the usage counts
++	  from hardware.
++
+ config ARM_RK3399_DMC_DEVFREQ
+ 	tristate "ARM RK3399 DMC DEVFREQ Driver"
+ 	depends on ARCH_ROCKCHIP
+@@ -123,9 +135,9 @@ config ARM_RK3399_DMC_DEVFREQ
+ 	select PM_DEVFREQ_EVENT
+ 	select PM_OPP
+ 	help
+-          This adds the DEVFREQ driver for the RK3399 DMC(Dynamic Memory Controller).
+-          It sets the frequency for the memory controller and reads the usage counts
+-          from hardware.
++	  This adds the DEVFREQ driver for the RK3399 DMC(Dynamic Memory Controller).
++	  It sets the frequency for the memory controller and reads the usage counts
++	  from hardware.
+ 
+ source "drivers/devfreq/event/Kconfig"
+ 
+diff --git a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
+index 338ae8440db6..ec568406ef50 100644
+--- a/drivers/devfreq/Makefile
++++ b/drivers/devfreq/Makefile
+@@ -10,6 +10,7 @@ obj-$(CONFIG_DEVFREQ_GOV_PASSIVE)	+= governor_passive.o
+ # DEVFREQ Drivers
+ obj-$(CONFIG_ARM_EXYNOS_BUS_DEVFREQ)	+= exynos-bus.o
+ obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
++obj-$(CONFIG_ARM_RK3328_DMC_DEVFREQ)	+= rk3328_dmc.o
+ obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
+ obj-$(CONFIG_ARM_TEGRA20_DEVFREQ)	+= tegra20-devfreq.o
+ 
+diff --git a/drivers/devfreq/rk3328_dmc.c b/drivers/devfreq/rk3328_dmc.c
+new file mode 100644
+index 000000000000..9e3c87019ada
+--- /dev/null
++++ b/drivers/devfreq/rk3328_dmc.c
+@@ -0,0 +1,846 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd.
++ * Author: Lin Huang <hl@rock-chips.com>
++ */
++
++#include <linux/arm-smccc.h>
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/devfreq.h>
++#include <linux/devfreq-event.h>
++#include <linux/interrupt.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/pm_opp.h>
++#include <linux/regmap.h>
++#include <linux/regulator/consumer.h>
++#include <linux/rwsem.h>
++#include <linux/suspend.h>
++
++#include <soc/rockchip/rockchip_sip.h>
++
++#define DTS_PAR_OFFSET		(4096)
++
++struct share_params {
++	u32 hz;
++	u32 lcdc_type;
++	u32 vop;
++	u32 vop_dclk_mode;
++	u32 sr_idle_en;
++	u32 addr_mcu_el3;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag1;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag0;
++	u32 complt_hwirq;
++	/* if need, add parameter after */
++};
++
++static struct share_params *ddr_psci_param;
++
++/* hope this define can adapt all future platform */
++static const char * const rk3328_dts_timing[] = {
++	"ddr3_speed_bin",
++	"ddr4_speed_bin",
++	"pd_idle",
++	"sr_idle",
++	"sr_mc_gate_idle",
++	"srpd_lite_idle",
++	"standby_idle",
++
++	"auto_pd_dis_freq",
++	"auto_sr_dis_freq",
++	"ddr3_dll_dis_freq",
++	"ddr4_dll_dis_freq",
++	"phy_dll_dis_freq",
++
++	"ddr3_odt_dis_freq",
++	"phy_ddr3_odt_dis_freq",
++	"ddr3_drv",
++	"ddr3_odt",
++	"phy_ddr3_ca_drv",
++	"phy_ddr3_ck_drv",
++	"phy_ddr3_dq_drv",
++	"phy_ddr3_odt",
++
++	"lpddr3_odt_dis_freq",
++	"phy_lpddr3_odt_dis_freq",
++	"lpddr3_drv",
++	"lpddr3_odt",
++	"phy_lpddr3_ca_drv",
++	"phy_lpddr3_ck_drv",
++	"phy_lpddr3_dq_drv",
++	"phy_lpddr3_odt",
++
++	"lpddr4_odt_dis_freq",
++	"phy_lpddr4_odt_dis_freq",
++	"lpddr4_drv",
++	"lpddr4_dq_odt",
++	"lpddr4_ca_odt",
++	"phy_lpddr4_ca_drv",
++	"phy_lpddr4_ck_cs_drv",
++	"phy_lpddr4_dq_drv",
++	"phy_lpddr4_odt",
++
++	"ddr4_odt_dis_freq",
++	"phy_ddr4_odt_dis_freq",
++	"ddr4_drv",
++	"ddr4_odt",
++	"phy_ddr4_ca_drv",
++	"phy_ddr4_ck_drv",
++	"phy_ddr4_dq_drv",
++	"phy_ddr4_odt",
++};
++
++static const char * const rk3328_dts_ca_timing[] = {
++	"ddr3a1_ddr4a9_de-skew",
++	"ddr3a0_ddr4a10_de-skew",
++	"ddr3a3_ddr4a6_de-skew",
++	"ddr3a2_ddr4a4_de-skew",
++	"ddr3a5_ddr4a8_de-skew",
++	"ddr3a4_ddr4a5_de-skew",
++	"ddr3a7_ddr4a11_de-skew",
++	"ddr3a6_ddr4a7_de-skew",
++	"ddr3a9_ddr4a0_de-skew",
++	"ddr3a8_ddr4a13_de-skew",
++	"ddr3a11_ddr4a3_de-skew",
++	"ddr3a10_ddr4cs0_de-skew",
++	"ddr3a13_ddr4a2_de-skew",
++	"ddr3a12_ddr4ba1_de-skew",
++	"ddr3a15_ddr4odt0_de-skew",
++	"ddr3a14_ddr4a1_de-skew",
++	"ddr3ba1_ddr4a15_de-skew",
++	"ddr3ba0_ddr4bg0_de-skew",
++	"ddr3ras_ddr4cke_de-skew",
++	"ddr3ba2_ddr4ba0_de-skew",
++	"ddr3we_ddr4bg1_de-skew",
++	"ddr3cas_ddr4a12_de-skew",
++	"ddr3ckn_ddr4ckn_de-skew",
++	"ddr3ckp_ddr4ckp_de-skew",
++	"ddr3cke_ddr4a16_de-skew",
++	"ddr3odt0_ddr4a14_de-skew",
++	"ddr3cs0_ddr4act_de-skew",
++	"ddr3reset_ddr4reset_de-skew",
++	"ddr3cs1_ddr4cs1_de-skew",
++	"ddr3odt1_ddr4odt1_de-skew",
++};
++
++static const char * const rk3328_dts_cs0_timing[] = {
++	"cs0_dm0_rx_de-skew",
++	"cs0_dm0_tx_de-skew",
++	"cs0_dq0_rx_de-skew",
++	"cs0_dq0_tx_de-skew",
++	"cs0_dq1_rx_de-skew",
++	"cs0_dq1_tx_de-skew",
++	"cs0_dq2_rx_de-skew",
++	"cs0_dq2_tx_de-skew",
++	"cs0_dq3_rx_de-skew",
++	"cs0_dq3_tx_de-skew",
++	"cs0_dq4_rx_de-skew",
++	"cs0_dq4_tx_de-skew",
++	"cs0_dq5_rx_de-skew",
++	"cs0_dq5_tx_de-skew",
++	"cs0_dq6_rx_de-skew",
++	"cs0_dq6_tx_de-skew",
++	"cs0_dq7_rx_de-skew",
++	"cs0_dq7_tx_de-skew",
++	"cs0_dqs0_rx_de-skew",
++	"cs0_dqs0p_tx_de-skew",
++	"cs0_dqs0n_tx_de-skew",
++
++	"cs0_dm1_rx_de-skew",
++	"cs0_dm1_tx_de-skew",
++	"cs0_dq8_rx_de-skew",
++	"cs0_dq8_tx_de-skew",
++	"cs0_dq9_rx_de-skew",
++	"cs0_dq9_tx_de-skew",
++	"cs0_dq10_rx_de-skew",
++	"cs0_dq10_tx_de-skew",
++	"cs0_dq11_rx_de-skew",
++	"cs0_dq11_tx_de-skew",
++	"cs0_dq12_rx_de-skew",
++	"cs0_dq12_tx_de-skew",
++	"cs0_dq13_rx_de-skew",
++	"cs0_dq13_tx_de-skew",
++	"cs0_dq14_rx_de-skew",
++	"cs0_dq14_tx_de-skew",
++	"cs0_dq15_rx_de-skew",
++	"cs0_dq15_tx_de-skew",
++	"cs0_dqs1_rx_de-skew",
++	"cs0_dqs1p_tx_de-skew",
++	"cs0_dqs1n_tx_de-skew",
++
++	"cs0_dm2_rx_de-skew",
++	"cs0_dm2_tx_de-skew",
++	"cs0_dq16_rx_de-skew",
++	"cs0_dq16_tx_de-skew",
++	"cs0_dq17_rx_de-skew",
++	"cs0_dq17_tx_de-skew",
++	"cs0_dq18_rx_de-skew",
++	"cs0_dq18_tx_de-skew",
++	"cs0_dq19_rx_de-skew",
++	"cs0_dq19_tx_de-skew",
++	"cs0_dq20_rx_de-skew",
++	"cs0_dq20_tx_de-skew",
++	"cs0_dq21_rx_de-skew",
++	"cs0_dq21_tx_de-skew",
++	"cs0_dq22_rx_de-skew",
++	"cs0_dq22_tx_de-skew",
++	"cs0_dq23_rx_de-skew",
++	"cs0_dq23_tx_de-skew",
++	"cs0_dqs2_rx_de-skew",
++	"cs0_dqs2p_tx_de-skew",
++	"cs0_dqs2n_tx_de-skew",
++
++	"cs0_dm3_rx_de-skew",
++	"cs0_dm3_tx_de-skew",
++	"cs0_dq24_rx_de-skew",
++	"cs0_dq24_tx_de-skew",
++	"cs0_dq25_rx_de-skew",
++	"cs0_dq25_tx_de-skew",
++	"cs0_dq26_rx_de-skew",
++	"cs0_dq26_tx_de-skew",
++	"cs0_dq27_rx_de-skew",
++	"cs0_dq27_tx_de-skew",
++	"cs0_dq28_rx_de-skew",
++	"cs0_dq28_tx_de-skew",
++	"cs0_dq29_rx_de-skew",
++	"cs0_dq29_tx_de-skew",
++	"cs0_dq30_rx_de-skew",
++	"cs0_dq30_tx_de-skew",
++	"cs0_dq31_rx_de-skew",
++	"cs0_dq31_tx_de-skew",
++	"cs0_dqs3_rx_de-skew",
++	"cs0_dqs3p_tx_de-skew",
++	"cs0_dqs3n_tx_de-skew",
++};
++
++static const char * const rk3328_dts_cs1_timing[] = {
++	"cs1_dm0_rx_de-skew",
++	"cs1_dm0_tx_de-skew",
++	"cs1_dq0_rx_de-skew",
++	"cs1_dq0_tx_de-skew",
++	"cs1_dq1_rx_de-skew",
++	"cs1_dq1_tx_de-skew",
++	"cs1_dq2_rx_de-skew",
++	"cs1_dq2_tx_de-skew",
++	"cs1_dq3_rx_de-skew",
++	"cs1_dq3_tx_de-skew",
++	"cs1_dq4_rx_de-skew",
++	"cs1_dq4_tx_de-skew",
++	"cs1_dq5_rx_de-skew",
++	"cs1_dq5_tx_de-skew",
++	"cs1_dq6_rx_de-skew",
++	"cs1_dq6_tx_de-skew",
++	"cs1_dq7_rx_de-skew",
++	"cs1_dq7_tx_de-skew",
++	"cs1_dqs0_rx_de-skew",
++	"cs1_dqs0p_tx_de-skew",
++	"cs1_dqs0n_tx_de-skew",
++
++	"cs1_dm1_rx_de-skew",
++	"cs1_dm1_tx_de-skew",
++	"cs1_dq8_rx_de-skew",
++	"cs1_dq8_tx_de-skew",
++	"cs1_dq9_rx_de-skew",
++	"cs1_dq9_tx_de-skew",
++	"cs1_dq10_rx_de-skew",
++	"cs1_dq10_tx_de-skew",
++	"cs1_dq11_rx_de-skew",
++	"cs1_dq11_tx_de-skew",
++	"cs1_dq12_rx_de-skew",
++	"cs1_dq12_tx_de-skew",
++	"cs1_dq13_rx_de-skew",
++	"cs1_dq13_tx_de-skew",
++	"cs1_dq14_rx_de-skew",
++	"cs1_dq14_tx_de-skew",
++	"cs1_dq15_rx_de-skew",
++	"cs1_dq15_tx_de-skew",
++	"cs1_dqs1_rx_de-skew",
++	"cs1_dqs1p_tx_de-skew",
++	"cs1_dqs1n_tx_de-skew",
++
++	"cs1_dm2_rx_de-skew",
++	"cs1_dm2_tx_de-skew",
++	"cs1_dq16_rx_de-skew",
++	"cs1_dq16_tx_de-skew",
++	"cs1_dq17_rx_de-skew",
++	"cs1_dq17_tx_de-skew",
++	"cs1_dq18_rx_de-skew",
++	"cs1_dq18_tx_de-skew",
++	"cs1_dq19_rx_de-skew",
++	"cs1_dq19_tx_de-skew",
++	"cs1_dq20_rx_de-skew",
++	"cs1_dq20_tx_de-skew",
++	"cs1_dq21_rx_de-skew",
++	"cs1_dq21_tx_de-skew",
++	"cs1_dq22_rx_de-skew",
++	"cs1_dq22_tx_de-skew",
++	"cs1_dq23_rx_de-skew",
++	"cs1_dq23_tx_de-skew",
++	"cs1_dqs2_rx_de-skew",
++	"cs1_dqs2p_tx_de-skew",
++	"cs1_dqs2n_tx_de-skew",
++
++	"cs1_dm3_rx_de-skew",
++	"cs1_dm3_tx_de-skew",
++	"cs1_dq24_rx_de-skew",
++	"cs1_dq24_tx_de-skew",
++	"cs1_dq25_rx_de-skew",
++	"cs1_dq25_tx_de-skew",
++	"cs1_dq26_rx_de-skew",
++	"cs1_dq26_tx_de-skew",
++	"cs1_dq27_rx_de-skew",
++	"cs1_dq27_tx_de-skew",
++	"cs1_dq28_rx_de-skew",
++	"cs1_dq28_tx_de-skew",
++	"cs1_dq29_rx_de-skew",
++	"cs1_dq29_tx_de-skew",
++	"cs1_dq30_rx_de-skew",
++	"cs1_dq30_tx_de-skew",
++	"cs1_dq31_rx_de-skew",
++	"cs1_dq31_tx_de-skew",
++	"cs1_dqs3_rx_de-skew",
++	"cs1_dqs3p_tx_de-skew",
++	"cs1_dqs3n_tx_de-skew",
++};
++
++struct rk3328_ddr_dts_config_timing {
++	unsigned int ddr3_speed_bin;
++	unsigned int ddr4_speed_bin;
++	unsigned int pd_idle;
++	unsigned int sr_idle;
++	unsigned int sr_mc_gate_idle;
++	unsigned int srpd_lite_idle;
++	unsigned int standby_idle;
++
++	unsigned int auto_pd_dis_freq;
++	unsigned int auto_sr_dis_freq;
++	/* for ddr3 only */
++	unsigned int ddr3_dll_dis_freq;
++	/* for ddr4 only */
++	unsigned int ddr4_dll_dis_freq;
++	unsigned int phy_dll_dis_freq;
++
++	unsigned int ddr3_odt_dis_freq;
++	unsigned int phy_ddr3_odt_dis_freq;
++	unsigned int ddr3_drv;
++	unsigned int ddr3_odt;
++	unsigned int phy_ddr3_ca_drv;
++	unsigned int phy_ddr3_ck_drv;
++	unsigned int phy_ddr3_dq_drv;
++	unsigned int phy_ddr3_odt;
++
++	unsigned int lpddr3_odt_dis_freq;
++	unsigned int phy_lpddr3_odt_dis_freq;
++	unsigned int lpddr3_drv;
++	unsigned int lpddr3_odt;
++	unsigned int phy_lpddr3_ca_drv;
++	unsigned int phy_lpddr3_ck_drv;
++	unsigned int phy_lpddr3_dq_drv;
++	unsigned int phy_lpddr3_odt;
++
++	unsigned int lpddr4_odt_dis_freq;
++	unsigned int phy_lpddr4_odt_dis_freq;
++	unsigned int lpddr4_drv;
++	unsigned int lpddr4_dq_odt;
++	unsigned int lpddr4_ca_odt;
++	unsigned int phy_lpddr4_ca_drv;
++	unsigned int phy_lpddr4_ck_cs_drv;
++	unsigned int phy_lpddr4_dq_drv;
++	unsigned int phy_lpddr4_odt;
++
++	unsigned int ddr4_odt_dis_freq;
++	unsigned int phy_ddr4_odt_dis_freq;
++	unsigned int ddr4_drv;
++	unsigned int ddr4_odt;
++	unsigned int phy_ddr4_ca_drv;
++	unsigned int phy_ddr4_ck_drv;
++	unsigned int phy_ddr4_dq_drv;
++	unsigned int phy_ddr4_odt;
++
++	unsigned int ca_skew[15];
++	unsigned int cs0_skew[44];
++	unsigned int cs1_skew[44];
++
++	unsigned int available;
++};
++
++struct rk3328_ddr_de_skew_setting {
++	unsigned int ca_de_skew[30];
++	unsigned int cs0_de_skew[84];
++	unsigned int cs1_de_skew[84];
++};
++
++struct rk3328_dmcfreq {
++	struct device *dev;
++	struct devfreq *devfreq;
++	struct devfreq_simple_ondemand_data ondemand_data;
++	struct clk *dmc_clk;
++	struct devfreq_event_dev *edev;
++	struct mutex lock;
++	struct regulator *vdd_center;
++	unsigned long rate, target_rate;
++	unsigned long volt, target_volt;
++
++	int (*set_auto_self_refresh)(u32 en);
++};
++
++static void
++rk3328_de_skew_setting_2_register(struct rk3328_ddr_de_skew_setting *de_skew,
++				  struct rk3328_ddr_dts_config_timing *tim)
++{
++	u32 n;
++	u32 offset;
++	u32 shift;
++
++	memset_io(tim->ca_skew, 0, sizeof(tim->ca_skew));
++	memset_io(tim->cs0_skew, 0, sizeof(tim->cs0_skew));
++	memset_io(tim->cs1_skew, 0, sizeof(tim->cs1_skew));
++
++	/* CA de-skew */
++	for (n = 0; n < ARRAY_SIZE(de_skew->ca_de_skew); n++) {
++		offset = n / 2;
++		shift = n % 2;
++		/* 0 => 4; 1 => 0 */
++		shift = (shift == 0) ? 4 : 0;
++		tim->ca_skew[offset] &= ~(0xf << shift);
++		tim->ca_skew[offset] |= (de_skew->ca_de_skew[n] << shift);
++	}
++
++	/* CS0 data de-skew */
++	for (n = 0; n < ARRAY_SIZE(de_skew->cs0_de_skew); n++) {
++		offset = ((n / 21) * 11) + ((n % 21) / 2);
++		shift = ((n % 21) % 2);
++		if ((n % 21) == 20)
++			shift = 0;
++		else
++			/* 0 => 4; 1 => 0 */
++			shift = (shift == 0) ? 4 : 0;
++		tim->cs0_skew[offset] &= ~(0xf << shift);
++		tim->cs0_skew[offset] |= (de_skew->cs0_de_skew[n] << shift);
++	}
++
++	/* CS1 data de-skew */
++	for (n = 0; n < ARRAY_SIZE(de_skew->cs1_de_skew); n++) {
++		offset = ((n / 21) * 11) + ((n % 21) / 2);
++		shift = ((n % 21) % 2);
++		if ((n % 21) == 20)
++			shift = 0;
++		else
++			/* 0 => 4; 1 => 0 */
++			shift = (shift == 0) ? 4 : 0;
++		tim->cs1_skew[offset] &= ~(0xf << shift);
++		tim->cs1_skew[offset] |= (de_skew->cs1_de_skew[n] << shift);
++	}
++}
++
++static void of_get_rk3328_timings(struct device *dev,
++				  struct device_node *np, uint32_t *timing)
++{
++	struct device_node *np_tim;
++	u32 *p;
++	struct rk3328_ddr_dts_config_timing *dts_timing;
++	struct rk3328_ddr_de_skew_setting *de_skew;
++	int ret = 0;
++	u32 i;
++
++	dts_timing =
++		(struct rk3328_ddr_dts_config_timing *)(timing +
++							DTS_PAR_OFFSET / 4);
++
++	np_tim = of_parse_phandle(np, "ddr_timing", 0);
++	if (!np_tim) {
++		ret = -EINVAL;
++		goto end;
++	}
++	de_skew = kmalloc(sizeof(*de_skew), GFP_KERNEL);
++	if (!de_skew) {
++		ret = -ENOMEM;
++		goto end;
++	}
++
++	p = (u32 *)dts_timing;
++	for (i = 0; i < ARRAY_SIZE(rk3328_dts_timing); i++) {
++		ret |= of_property_read_u32(np_tim, rk3328_dts_timing[i],
++					p + i);
++	}
++	p = (u32 *)de_skew->ca_de_skew;
++	for (i = 0; i < ARRAY_SIZE(rk3328_dts_ca_timing); i++) {
++		ret |= of_property_read_u32(np_tim, rk3328_dts_ca_timing[i],
++					p + i);
++	}
++	p = (u32 *)de_skew->cs0_de_skew;
++	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs0_timing); i++) {
++		ret |= of_property_read_u32(np_tim, rk3328_dts_cs0_timing[i],
++					p + i);
++	}
++	p = (u32 *)de_skew->cs1_de_skew;
++	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs1_timing); i++) {
++		ret |= of_property_read_u32(np_tim, rk3328_dts_cs1_timing[i],
++					p + i);
++	}
++	if (!ret)
++		rk3328_de_skew_setting_2_register(de_skew, dts_timing);
++
++	kfree(de_skew);
++end:
++	if (!ret) {
++		dts_timing->available = 1;
++	} else {
++		dts_timing->available = 0;
++		dev_err(dev, "of_get_ddr_timings: fail\n");
++	}
++
++	of_node_put(np_tim);
++}
++
++static int rockchip_ddr_set_auto_self_refresh(uint32_t en)
++{
++	struct arm_smccc_res res;
++
++	ddr_psci_param->sr_idle_en = en;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_SET_AT_SR,
++		      0, 0, 0, 0, &res);
++
++	return res.a0;
++}
++
++static int rk3328_dmc_init(struct platform_device *pdev,
++			   struct rk3328_dmcfreq *dmcfreq)
++{
++	struct arm_smccc_res res;
++	u32 size, page_num;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      0, 0, ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION,
++		      0, 0, 0, 0, &res);
++	if (res.a0 || (res.a1 < 0x101)) {
++		dev_err(&pdev->dev,
++			"trusted firmware need to update or is invalid\n");
++		return -ENXIO;
++	}
++
++	dev_notice(&pdev->dev, "current ATF version 0x%lx\n", res.a1);
++
++	/*
++	 * first 4KB is used for interface parameters
++	 * after 4KB * N is dts parameters
++	 */
++	size = sizeof(struct rk3328_ddr_dts_config_timing);
++	page_num = DIV_ROUND_UP(size, 4096) + 1;
++
++	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
++		      page_num, SHARE_PAGE_TYPE_DDR, 0,
++		      0, 0, 0, 0, &res);
++	if (res.a0 != 0) {
++		dev_err(&pdev->dev, "no ATF memory for init\n");
++		return -ENOMEM;
++	}
++
++	ddr_psci_param = ioremap(res.a1, page_num << 12);
++	of_get_rk3328_timings(&pdev->dev, pdev->dev.of_node,
++			      (uint32_t *)ddr_psci_param);
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_INIT,
++		      0, 0, 0, 0, &res);
++	if (res.a0) {
++		dev_err(&pdev->dev, "Rockchip dram init error %lx\n", res.a0);
++		return -ENOMEM;
++	}
++
++	dmcfreq->set_auto_self_refresh = rockchip_ddr_set_auto_self_refresh;
++
++	return 0;
++}
++
++static int rk3328_dmcfreq_target(struct device *dev, unsigned long *freq,
++				 u32 flags)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++	struct dev_pm_opp *opp;
++	unsigned long old_clk_rate = dmcfreq->rate;
++	unsigned long target_volt, target_rate;
++	int err;
++
++	opp = devfreq_recommended_opp(dev, freq, flags);
++	if (IS_ERR(opp))
++		return PTR_ERR(opp);
++
++	target_rate = dev_pm_opp_get_freq(opp);
++	target_volt = dev_pm_opp_get_voltage(opp);
++	dev_pm_opp_put(opp);
++
++	if (dmcfreq->rate == target_rate)
++		return 0;
++
++	mutex_lock(&dmcfreq->lock);
++
++	/*
++	 * If frequency scaling from low to high, adjust voltage first.
++	 * If frequency scaling from high to low, adjust frequency first.
++	 */
++	if (old_clk_rate < target_rate) {
++		err = regulator_set_voltage(dmcfreq->vdd_center, target_volt,
++					    target_volt);
++		if (err) {
++			dev_err(dev, "Cannot set voltage %lu uV\n",
++				target_volt);
++			goto out;
++		}
++	}
++
++	err = clk_set_rate(dmcfreq->dmc_clk, target_rate);
++	if (err) {
++		dev_err(dev, "Cannot set frequency %lu (%d)\n", target_rate,
++			err);
++		regulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,
++				      dmcfreq->volt);
++		goto out;
++	}
++
++	/*
++	 * Check the dpll rate,
++	 * There only two result we will get,
++	 * 1. Ddr frequency scaling fail, we still get the old rate.
++	 * 2. Ddr frequency scaling sucessful, we get the rate we set.
++	 */
++	dmcfreq->rate = clk_get_rate(dmcfreq->dmc_clk);
++
++	/* If get the incorrect rate, set voltage to old value. */
++	if (dmcfreq->rate != target_rate) {
++		dev_err(dev, "Got wrong frequency, Request %lu, Current %lu\n",
++			target_rate, dmcfreq->rate);
++		regulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,
++				      dmcfreq->volt);
++		goto out;
++	} else if (old_clk_rate > target_rate)
++		err = regulator_set_voltage(dmcfreq->vdd_center, target_volt,
++					    target_volt);
++	if (err)
++		dev_err(dev, "Cannot set voltage %lu uV\n", target_volt);
++
++	dmcfreq->rate = target_rate;
++	dmcfreq->volt = target_volt;
++
++out:
++	mutex_unlock(&dmcfreq->lock);
++	return err;
++}
++
++static int rk3328_dmcfreq_get_dev_status(struct device *dev,
++					 struct devfreq_dev_status *stat)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++	struct devfreq_event_data edata;
++	int ret = 0;
++
++	ret = devfreq_event_get_event(dmcfreq->edev, &edata);
++	if (ret < 0)
++		return ret;
++
++	stat->current_frequency = dmcfreq->rate;
++	stat->busy_time = edata.load_count;
++	stat->total_time = edata.total_count;
++
++	return ret;
++}
++
++static int rk3328_dmcfreq_get_cur_freq(struct device *dev, unsigned long *freq)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++
++	*freq = dmcfreq->rate;
++
++	return 0;
++}
++
++static struct devfreq_dev_profile rk3328_devfreq_dmc_profile = {
++	.polling_ms	= 200,
++	.target		= rk3328_dmcfreq_target,
++	.get_dev_status	= rk3328_dmcfreq_get_dev_status,
++	.get_cur_freq	= rk3328_dmcfreq_get_cur_freq,
++};
++
++static __maybe_unused int rk3328_dmcfreq_suspend(struct device *dev)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++	int ret = 0;
++
++	ret = devfreq_event_disable_edev(dmcfreq->edev);
++	if (ret < 0) {
++		dev_err(dev, "failed to disable the devfreq-event devices\n");
++		return ret;
++	}
++
++	ret = devfreq_suspend_device(dmcfreq->devfreq);
++	if (ret < 0) {
++		dev_err(dev, "failed to suspend the devfreq devices\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static __maybe_unused int rk3328_dmcfreq_resume(struct device *dev)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
++	int ret = 0;
++
++	ret = devfreq_event_enable_edev(dmcfreq->edev);
++	if (ret < 0) {
++		dev_err(dev, "failed to enable the devfreq-event devices\n");
++		return ret;
++	}
++
++	ret = devfreq_resume_device(dmcfreq->devfreq);
++	if (ret < 0) {
++		dev_err(dev, "failed to resume the devfreq devices\n");
++		return ret;
++	}
++	return ret;
++}
++
++static SIMPLE_DEV_PM_OPS(rk3328_dmcfreq_pm, rk3328_dmcfreq_suspend,
++			 rk3328_dmcfreq_resume);
++
++static int rk3328_dmcfreq_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = pdev->dev.of_node;
++	struct rk3328_dmcfreq *data;
++	struct dev_pm_opp *opp;
++	int ret;
++
++	data = devm_kzalloc(dev, sizeof(struct rk3328_dmcfreq), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	mutex_init(&data->lock);
++
++	data->vdd_center = devm_regulator_get(dev, "center");
++	if (IS_ERR(data->vdd_center)) {
++		if (PTR_ERR(data->vdd_center) == -EPROBE_DEFER)
++			return -EPROBE_DEFER;
++
++		dev_err(dev, "Cannot get the regulator \"center\"\n");
++		return PTR_ERR(data->vdd_center);
++	}
++
++	data->dmc_clk = devm_clk_get(dev, "dmc_clk");
++	if (IS_ERR(data->dmc_clk)) {
++		if (PTR_ERR(data->dmc_clk) == -EPROBE_DEFER)
++			return -EPROBE_DEFER;
++
++		dev_err(dev, "Cannot get the clk dmc_clk\n");
++		return PTR_ERR(data->dmc_clk);
++	}
++
++	data->edev = devfreq_event_get_edev_by_phandle(dev, 0);
++	if (IS_ERR(data->edev))
++		return -EPROBE_DEFER;
++
++	ret = devfreq_event_enable_edev(data->edev);
++	if (ret < 0) {
++		dev_err(dev, "failed to enable devfreq-event devices\n");
++		return ret;
++	}
++
++	ret = rk3328_dmc_init(pdev, data);
++	if (ret)
++		return ret;
++
++	/*
++	 * We add a devfreq driver to our parent since it has a device tree node
++	 * with operating points.
++	 */
++	if (dev_pm_opp_of_add_table(dev)) {
++		dev_err(dev, "Invalid operating-points in device tree.\n");
++		return -EINVAL;
++	}
++
++	of_property_read_u32(np, "upthreshold",
++			     &data->ondemand_data.upthreshold);
++	of_property_read_u32(np, "downdifferential",
++			     &data->ondemand_data.downdifferential);
++
++	data->rate = clk_get_rate(data->dmc_clk);
++
++	opp = devfreq_recommended_opp(dev, &data->rate, 0);
++	if (IS_ERR(opp)) {
++		ret = PTR_ERR(opp);
++		goto err_free_opp;
++	}
++
++	data->rate = dev_pm_opp_get_freq(opp);
++	data->volt = dev_pm_opp_get_voltage(opp);
++	dev_pm_opp_put(opp);
++
++	rk3328_devfreq_dmc_profile.initial_freq = data->rate;
++
++	data->devfreq = devm_devfreq_add_device(dev,
++					   &rk3328_devfreq_dmc_profile,
++					   DEVFREQ_GOV_SIMPLE_ONDEMAND,
++					   &data->ondemand_data);
++	if (IS_ERR(data->devfreq)) {
++		ret = PTR_ERR(data->devfreq);
++		goto err_free_opp;
++	}
++
++	devm_devfreq_register_opp_notifier(dev, data->devfreq);
++
++	data->dev = dev;
++	platform_set_drvdata(pdev, data);
++
++	return 0;
++
++err_free_opp:
++	dev_pm_opp_of_remove_table(&pdev->dev);
++	return ret;
++}
++
++static int rk3328_dmcfreq_remove(struct platform_device *pdev)
++{
++	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(&pdev->dev);
++
++	/*
++	 * Before remove the opp table we need to unregister the opp notifier.
++	 */
++	devm_devfreq_unregister_opp_notifier(dmcfreq->dev, dmcfreq->devfreq);
++	dev_pm_opp_of_remove_table(dmcfreq->dev);
++
++	return 0;
++}
++
++static const struct of_device_id rk3328dmc_devfreq_of_match[] = {
++	{ .compatible = "rockchip,rk3328-dmc" },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, rk3328dmc_devfreq_of_match);
++
++static struct platform_driver rk3328_dmcfreq_driver = {
++	.probe	= rk3328_dmcfreq_probe,
++	.remove = rk3328_dmcfreq_remove,
++	.driver = {
++		.name	= "rk3328-dmc-freq",
++		.pm	= &rk3328_dmcfreq_pm,
++		.of_match_table = rk3328dmc_devfreq_of_match,
++	},
++};
++module_platform_driver(rk3328_dmcfreq_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_AUTHOR("Lin Huang <hl@rock-chips.com>");
++MODULE_DESCRIPTION("RK3328 dmcfreq driver with devfreq framework");
+From ce6d3614888e6358466f0e84e248177a6bca5258 Mon Sep 17 00:00:00 2001
+From: Tang Yun ping <typ@rock-chips.com>
+Date: Thu, 4 May 2017 20:49:58 +0800
+Subject: [PATCH] clk: rockchip: support setting ddr clock via SIP Version 2
+ APIs
+
+commit 764e893ee82321938fc6f4349e9e7caf06a04410 rockchip.
+
+Signed-off-by: Tang Yun ping <typ@rock-chips.com>
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/clk/rockchip/clk-ddr.c      | 130 ++++++++++++++++++++++++++++
+ drivers/clk/rockchip/clk-rk3328.c   |   7 +-
+ drivers/clk/rockchip/clk.h          |   3 +-
+ include/soc/rockchip/rockchip_sip.h |  11 +++
+ 4 files changed, 147 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/clk/rockchip/clk-ddr.c b/drivers/clk/rockchip/clk-ddr.c
+index 9273bce4d7b6..555aaf4e758d 100644
+--- a/drivers/clk/rockchip/clk-ddr.c
++++ b/drivers/clk/rockchip/clk-ddr.c
+@@ -87,6 +87,133 @@ static const struct clk_ops rockchip_ddrclk_sip_ops = {
+ 	.get_parent = rockchip_ddrclk_get_parent,
+ };
+
++/* See v4.4/include/dt-bindings/display/rk_fb.h */
++#define SCREEN_NULL			0
++#define SCREEN_HDMI			6
++
++static inline int rk_drm_get_lcdc_type(void)
++{
++	return SCREEN_NULL;
++}
++
++struct share_params {
++	u32 hz;
++	u32 lcdc_type;
++	u32 vop;
++	u32 vop_dclk_mode;
++	u32 sr_idle_en;
++	u32 addr_mcu_el3;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag1;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag0;
++	u32 complt_hwirq;
++	 /* if need, add parameter after */
++};
++
++struct rockchip_ddrclk_data {
++	u32 inited_flag;
++	void __iomem *share_memory;
++};
++
++static struct rockchip_ddrclk_data ddr_data;
++
++static void rockchip_ddrclk_data_init(void)
++{
++	struct arm_smccc_res res;
++
++	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
++		      1, SHARE_PAGE_TYPE_DDR, 0,
++		      0, 0, 0, 0, &res);
++
++	if (!res.a0) {
++		ddr_data.share_memory = (void __iomem *)ioremap(res.a1, 1<<12);
++		ddr_data.inited_flag = 1;
++	}
++}
++
++static int rockchip_ddrclk_sip_set_rate_v2(struct clk_hw *hw,
++					   unsigned long drate,
++					   unsigned long prate)
++{
++	struct share_params *p;
++	struct arm_smccc_res res;
++
++	if (!ddr_data.inited_flag)
++		rockchip_ddrclk_data_init();
++
++	p = (struct share_params *)ddr_data.share_memory;
++
++	p->hz = drate;
++	p->lcdc_type = rk_drm_get_lcdc_type();
++	p->wait_flag1 = 1;
++	p->wait_flag0 = 1;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,
++		      0, 0, 0, 0, &res);
++
++	if ((int)res.a1 == -6) {
++		pr_err("%s: timeout, drate = %lumhz\n", __func__, drate/1000000);
++		/* TODO: rockchip_dmcfreq_wait_complete(); */
++	}
++
++	return res.a0;
++}
++
++static unsigned long rockchip_ddrclk_sip_recalc_rate_v2
++			(struct clk_hw *hw, unsigned long parent_rate)
++{
++	struct arm_smccc_res res;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE,
++		      0, 0, 0, 0, &res);
++	if (!res.a0)
++		return res.a1;
++	else
++		return 0;
++}
++
++static long rockchip_ddrclk_sip_round_rate_v2(struct clk_hw *hw,
++					      unsigned long rate,
++					      unsigned long *prate)
++{
++	struct share_params *p;
++	struct arm_smccc_res res;
++
++	if (!ddr_data.inited_flag)
++		rockchip_ddrclk_data_init();
++
++	p = (struct share_params *)ddr_data.share_memory;
++
++	p->hz = rate;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE,
++		      0, 0, 0, 0, &res);
++	if (!res.a0)
++		return res.a1;
++	else
++		return 0;
++}
++
++static const struct clk_ops rockchip_ddrclk_sip_ops_v2 = {
++	.recalc_rate = rockchip_ddrclk_sip_recalc_rate_v2,
++	.set_rate = rockchip_ddrclk_sip_set_rate_v2,
++	.round_rate = rockchip_ddrclk_sip_round_rate_v2,
++	.get_parent = rockchip_ddrclk_get_parent,
++};
++
+ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 					 const char *const *parent_names,
+ 					 u8 num_parents, int mux_offset,
+@@ -114,6 +241,9 @@ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 	case ROCKCHIP_DDRCLK_SIP:
+ 		init.ops = &rockchip_ddrclk_sip_ops;
+ 		break;
++	case ROCKCHIP_DDRCLK_SIP_V2:
++		init.ops = &rockchip_ddrclk_sip_ops_v2;
++		break;
+ 	default:
+ 		pr_err("%s: unsupported ddrclk type %d\n", __func__, ddr_flag);
+ 		kfree(ddrclk);
+diff --git a/drivers/clk/rockchip/clk-rk3328.c b/drivers/clk/rockchip/clk-rk3328.c
+index c186a1985bf4..ac6e6163a232 100644
+--- a/drivers/clk/rockchip/clk-rk3328.c
++++ b/drivers/clk/rockchip/clk-rk3328.c
+@@ -314,9 +314,10 @@ static struct rockchip_clk_branch rk3328_clk_branches[] __initdata = {
+ 			RK3328_CLKGATE_CON(14), 1, GFLAGS),
+
+ 	/* PD_DDR */
+-	COMPOSITE(0, "clk_ddr", mux_ddrphy_p, CLK_IGNORE_UNUSED,
+-			RK3328_CLKSEL_CON(3), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
+-			RK3328_CLKGATE_CON(0), 4, GFLAGS),
++	COMPOSITE_DDRCLK(SCLK_DDRCLK, "sclk_ddrc", mux_ddrphy_p, 0,
++			RK3328_CLKSEL_CON(3), 8, 2, 0, 3,
++			ROCKCHIP_DDRCLK_SIP_V2),
++
+ 	GATE(0, "clk_ddrmsch", "clk_ddr", CLK_IGNORE_UNUSED,
+ 			RK3328_CLKGATE_CON(18), 6, GFLAGS),
+ 	GATE(0, "clk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
+diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
+index 2271a84124b0..7405aaf965ec 100644
+--- a/drivers/clk/rockchip/clk.h
++++ b/drivers/clk/rockchip/clk.h
+@@ -362,7 +362,8 @@ struct clk *rockchip_clk_register_mmc(const char *name,
+  * DDRCLK flags, including method of setting the rate
+  * ROCKCHIP_DDRCLK_SIP: use SIP call to bl31 to change ddrclk rate.
+  */
+-#define ROCKCHIP_DDRCLK_SIP		BIT(0)
++#define ROCKCHIP_DDRCLK_SIP		0x01
++#define ROCKCHIP_DDRCLK_SIP_V2		0x03
+
+ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 					 const char *const *parent_names,
+diff --git a/include/soc/rockchip/rockchip_sip.h b/include/soc/rockchip/rockchip_sip.h
+index c46a9ae2a2ab..fa7e0a2d72cc 100644
+--- a/include/soc/rockchip/rockchip_sip.h
++++ b/include/soc/rockchip/rockchip_sip.h
+@@ -16,5 +16,16 @@
+ #define ROCKCHIP_SIP_CONFIG_DRAM_CLR_IRQ	0x06
+ #define ROCKCHIP_SIP_CONFIG_DRAM_SET_PARAM	0x07
+ #define ROCKCHIP_SIP_CONFIG_DRAM_SET_ODT_PD	0x08
++#define ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION	0x08
++
++#define ROCKCHIP_SIP_SHARE_MEM			0x82000009
++
++/* Share mem page types */
++typedef enum {
++    SHARE_PAGE_TYPE_INVALID = 0,
++    SHARE_PAGE_TYPE_UARTDBG,
++    SHARE_PAGE_TYPE_DDR,
++    SHARE_PAGE_TYPE_MAX,
++} share_page_type_t;
+
+ #endif
+From 4db93c6dad0c71750b86163df2fdb21c35f00d9a Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 12:49:48 +0800
+Subject: [PATCH] PM / devfreq: rockchip-dfi: add more soc support
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/devfreq/event/rockchip-dfi.c | 554 ++++++++++++++++++++++++---
+ 1 file changed, 505 insertions(+), 49 deletions(-)
+
+diff --git a/drivers/devfreq/event/rockchip-dfi.c b/drivers/devfreq/event/rockchip-dfi.c
+index 5d1042188727..80be0efdfb9b 100644
+--- a/drivers/devfreq/event/rockchip-dfi.c
++++ b/drivers/devfreq/event/rockchip-dfi.c
+@@ -18,25 +18,66 @@
+ #include <linux/list.h>
+ #include <linux/of.h>
+ 
+-#include <soc/rockchip/rk3399_grf.h>
+-
+-#define RK3399_DMC_NUM_CH	2
+-
++#define PX30_PMUGRF_OS_REG2		0x208
++
++#define RK3128_GRF_SOC_CON0		0x140
++#define RK3128_GRF_OS_REG1		0x1cc
++#define RK3128_GRF_DFI_WRNUM		0x220
++#define RK3128_GRF_DFI_RDNUM		0x224
++#define RK3128_GRF_DFI_TIMERVAL		0x22c
++#define RK3128_DDR_MONITOR_EN		((1 << (16 + 6)) + (1 << 6))
++#define RK3128_DDR_MONITOR_DISB		((1 << (16 + 6)) + (0 << 6))
++
++#define RK3288_PMU_SYS_REG2		0x9c
++#define RK3288_GRF_SOC_CON4		0x254
++#define RK3288_GRF_SOC_STATUS(n)	(0x280 + (n) * 4)
++#define RK3288_DFI_EN			(0x30003 << 14)
++#define RK3288_DFI_DIS			(0x30000 << 14)
++#define RK3288_LPDDR_SEL		(0x10001 << 13)
++#define RK3288_DDR3_SEL			(0x10000 << 13)
++
++#define RK3328_GRF_OS_REG2		0x5d0
++
++#define RK3368_GRF_DDRC0_CON0		0x600
++#define RK3368_GRF_SOC_STATUS5		0x494
++#define RK3368_GRF_SOC_STATUS6		0x498
++#define RK3368_GRF_SOC_STATUS8		0x4a0
++#define RK3368_GRF_SOC_STATUS9		0x4a4
++#define RK3368_GRF_SOC_STATUS10		0x4a8
++#define RK3368_DFI_EN			(0x30003 << 5)
++#define RK3368_DFI_DIS			(0x30000 << 5)
++
++#define MAX_DMC_NUM_CH			2
++#define READ_DRAMTYPE_INFO(n)		(((n) >> 13) & 0x7)
++#define READ_CH_INFO(n)			(((n) >> 28) & 0x3)
+ /* DDRMON_CTRL */
+-#define DDRMON_CTRL	0x04
+-#define CLR_DDRMON_CTRL	(0x1f0000 << 0)
+-#define LPDDR4_EN	(0x10001 << 4)
+-#define HARDWARE_EN	(0x10001 << 3)
+-#define LPDDR3_EN	(0x10001 << 2)
+-#define SOFTWARE_EN	(0x10001 << 1)
+-#define SOFTWARE_DIS	(0x10000 << 1)
+-#define TIME_CNT_EN	(0x10001 << 0)
++#define DDRMON_CTRL			0x04
++#define CLR_DDRMON_CTRL			(0x3f0000 << 0)
++#define DDR4_EN				(0x10001 << 5)
++#define LPDDR4_EN			(0x10001 << 4)
++#define HARDWARE_EN			(0x10001 << 3)
++#define LPDDR2_3_EN			(0x10001 << 2)
++#define SOFTWARE_EN			(0x10001 << 1)
++#define SOFTWARE_DIS			(0x10000 << 1)
++#define TIME_CNT_EN			(0x10001 << 0)
+ 
+ #define DDRMON_CH0_COUNT_NUM		0x28
+ #define DDRMON_CH0_DFI_ACCESS_NUM	0x2c
+ #define DDRMON_CH1_COUNT_NUM		0x3c
+ #define DDRMON_CH1_DFI_ACCESS_NUM	0x40
+ 
++/* pmu grf */
++#define PMUGRF_OS_REG2			0x308
++
++enum {
++	DDR4 = 0,
++	DDR3 = 3,
++	LPDDR2 = 5,
++	LPDDR3 = 6,
++	LPDDR4 = 7,
++	UNUSED = 0xFF
++};
++
+ struct dmc_usage {
+ 	u32 access;
+ 	u32 total;
+@@ -50,33 +91,261 @@ struct dmc_usage {
+ struct rockchip_dfi {
+ 	struct devfreq_event_dev *edev;
+ 	struct devfreq_event_desc *desc;
+-	struct dmc_usage ch_usage[RK3399_DMC_NUM_CH];
++	struct dmc_usage ch_usage[MAX_DMC_NUM_CH];
+ 	struct device *dev;
+ 	void __iomem *regs;
+ 	struct regmap *regmap_pmu;
++	struct regmap *regmap_grf;
++	struct regmap *regmap_pmugrf;
+ 	struct clk *clk;
++	u32 dram_type;
++	/*
++	 * available mask, 1: available, 0: not available
++	 * each bit represent a channel
++	 */
++	u32 ch_msk;
++};
++
++static void rk3128_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf,
++		     RK3128_GRF_SOC_CON0,
++		     RK3128_DDR_MONITOR_EN);
++}
++
++static void rk3128_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf,
++		     RK3128_GRF_SOC_CON0,
++		     RK3128_DDR_MONITOR_DISB);
++}
++
++static int rk3128_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3128_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3128_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3128_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3128_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3128_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	unsigned long flags;
++	u32 dfi_wr, dfi_rd, dfi_timer;
++
++	local_irq_save(flags);
++
++	rk3128_dfi_stop_hardware_counter(edev);
++
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_WRNUM, &dfi_wr);
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_RDNUM, &dfi_rd);
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_TIMERVAL, &dfi_timer);
++
++	edata->load_count = (dfi_wr + dfi_rd) * 4;
++	edata->total_count = dfi_timer;
++
++	rk3128_dfi_start_hardware_counter(edev);
++
++	local_irq_restore(flags);
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3128_dfi_ops = {
++	.disable = rk3128_dfi_disable,
++	.enable = rk3128_dfi_enable,
++	.get_event = rk3128_dfi_get_event,
++	.set_event = rk3128_dfi_set_event,
++};
++
++static void rk3288_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_EN);
++}
++
++static void rk3288_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_DIS);
++}
++
++static int rk3288_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3288_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3288_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3288_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3288_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3288_dfi_get_busier_ch(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	u32 tmp, max = 0;
++	u32 i, busier_ch = 0;
++	u32 rd_count, wr_count, total_count;
++
++	rk3288_dfi_stop_hardware_counter(edev);
++
++	/* Find out which channel is busier */
++	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
++		if (!(info->ch_msk & BIT(i)))
++			continue;
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(11 + i * 4), &wr_count);
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(12 + i * 4), &rd_count);
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(14 + i * 4), &total_count);
++		info->ch_usage[i].access = (wr_count + rd_count) * 4;
++		info->ch_usage[i].total = total_count;
++		tmp = info->ch_usage[i].access;
++		if (tmp > max) {
++			busier_ch = i;
++			max = tmp;
++		}
++	}
++	rk3288_dfi_start_hardware_counter(edev);
++
++	return busier_ch;
++}
++
++static int rk3288_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	int busier_ch;
++	unsigned long flags;
++
++	local_irq_save(flags);
++	busier_ch = rk3288_dfi_get_busier_ch(edev);
++	local_irq_restore(flags);
++
++	edata->load_count = info->ch_usage[busier_ch].access;
++	edata->total_count = info->ch_usage[busier_ch].total;
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3288_dfi_ops = {
++	.disable = rk3288_dfi_disable,
++	.enable = rk3288_dfi_enable,
++	.get_event = rk3288_dfi_get_event,
++	.set_event = rk3288_dfi_set_event,
++};
++
++static void rk3368_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_EN);
++}
++
++static void rk3368_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_DIS);
++}
++
++static int rk3368_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3368_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3368_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3368_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3368_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3368_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	unsigned long flags;
++	u32 dfi0_wr, dfi0_rd, dfi1_wr, dfi1_rd, dfi_timer;
++
++	local_irq_save(flags);
++
++	rk3368_dfi_stop_hardware_counter(edev);
++
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS5, &dfi0_wr);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS6, &dfi0_rd);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS9, &dfi1_wr);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS10, &dfi1_rd);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS8, &dfi_timer);
++
++	edata->load_count = (dfi0_wr + dfi0_rd + dfi1_wr + dfi1_rd) * 2;
++	edata->total_count = dfi_timer;
++
++	rk3368_dfi_start_hardware_counter(edev);
++
++	local_irq_restore(flags);
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3368_dfi_ops = {
++	.disable = rk3368_dfi_disable,
++	.enable = rk3368_dfi_enable,
++	.get_event = rk3368_dfi_get_event,
++	.set_event = rk3368_dfi_set_event,
+ };
+ 
+ static void rockchip_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
+ {
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	void __iomem *dfi_regs = info->regs;
+-	u32 val;
+-	u32 ddr_type;
+-
+-	/* get ddr type */
+-	regmap_read(info->regmap_pmu, RK3399_PMUGRF_OS_REG2, &val);
+-	ddr_type = (val >> RK3399_PMUGRF_DDRTYPE_SHIFT) &
+-		    RK3399_PMUGRF_DDRTYPE_MASK;
+ 
+ 	/* clear DDRMON_CTRL setting */
+ 	writel_relaxed(CLR_DDRMON_CTRL, dfi_regs + DDRMON_CTRL);
+ 
+ 	/* set ddr type to dfi */
+-	if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR3)
+-		writel_relaxed(LPDDR3_EN, dfi_regs + DDRMON_CTRL);
+-	else if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR4)
++	if (info->dram_type == LPDDR3 || info->dram_type == LPDDR2)
++		writel_relaxed(LPDDR2_3_EN, dfi_regs + DDRMON_CTRL);
++	else if (info->dram_type == LPDDR4)
+ 		writel_relaxed(LPDDR4_EN, dfi_regs + DDRMON_CTRL);
++	else if (info->dram_type == DDR4)
++		writel_relaxed(DDR4_EN, dfi_regs + DDRMON_CTRL);
+ 
+ 	/* enable count, use software mode */
+ 	writel_relaxed(SOFTWARE_EN, dfi_regs + DDRMON_CTRL);
+@@ -100,12 +369,22 @@ static int rockchip_dfi_get_busier_ch(struct devfreq_event_dev *edev)
+ 	rockchip_dfi_stop_hardware_counter(edev);
+ 
+ 	/* Find out which channel is busier */
+-	for (i = 0; i < RK3399_DMC_NUM_CH; i++) {
+-		info->ch_usage[i].access = readl_relaxed(dfi_regs +
+-				DDRMON_CH0_DFI_ACCESS_NUM + i * 20) * 4;
++	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
++		if (!(info->ch_msk & BIT(i)))
++			continue;
++
+ 		info->ch_usage[i].total = readl_relaxed(dfi_regs +
+ 				DDRMON_CH0_COUNT_NUM + i * 20);
+-		tmp = info->ch_usage[i].access;
++
++		/* LPDDR4 BL = 16,other DDR type BL = 8 */
++		tmp = readl_relaxed(dfi_regs +
++				DDRMON_CH0_DFI_ACCESS_NUM + i * 20);
++		if (info->dram_type == LPDDR4)
++			tmp *= 8;
++		else
++			tmp *= 4;
++		info->ch_usage[i].access = tmp;
++
+ 		if (tmp > max) {
+ 			busier_ch = i;
+ 			max = tmp;
+@@ -121,7 +400,8 @@ static int rockchip_dfi_disable(struct devfreq_event_dev *edev)
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 
+ 	rockchip_dfi_stop_hardware_counter(edev);
+-	clk_disable_unprepare(info->clk);
++	if (info->clk)
++		clk_disable_unprepare(info->clk);
+ 
+ 	return 0;
+ }
+@@ -131,10 +411,13 @@ static int rockchip_dfi_enable(struct devfreq_event_dev *edev)
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	int ret;
+ 
+-	ret = clk_prepare_enable(info->clk);
+-	if (ret) {
+-		dev_err(&edev->dev, "failed to enable dfi clk: %d\n", ret);
+-		return ret;
++	if (info->clk) {
++		ret = clk_prepare_enable(info->clk);
++		if (ret) {
++			dev_err(&edev->dev, "failed to enable dfi clk: %d\n",
++				ret);
++			return ret;
++		}
+ 	}
+ 
+ 	rockchip_dfi_start_hardware_counter(edev);
+@@ -151,8 +434,11 @@ static int rockchip_dfi_get_event(struct devfreq_event_dev *edev,
+ {
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	int busier_ch;
++	unsigned long flags;
+ 
++	local_irq_save(flags);
+ 	busier_ch = rockchip_dfi_get_busier_ch(edev);
++	local_irq_restore(flags);
+ 
+ 	edata->load_count = info->ch_usage[busier_ch].access;
+ 	edata->total_count = info->ch_usage[busier_ch].total;
+@@ -167,23 +453,117 @@ static const struct devfreq_event_ops rockchip_dfi_ops = {
+ 	.set_event = rockchip_dfi_set_event,
+ };
+ 
+-static const struct of_device_id rockchip_dfi_id_match[] = {
+-	{ .compatible = "rockchip,rk3399-dfi" },
+-	{ },
+-};
+-MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
++static __init int px30_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	struct resource *res;
++	u32 val;
+ 
+-static int rockchip_dfi_probe(struct platform_device *pdev)
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs))
++		return PTR_ERR(data->regs);
++
++	node = of_parse_phandle(np, "rockchip,pmugrf", 0);
++	if (node) {
++		data->regmap_pmugrf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_pmugrf))
++			return PTR_ERR(data->regmap_pmugrf);
++	}
++
++	regmap_read(data->regmap_pmugrf, PX30_PMUGRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = 1;
++	data->clk = NULL;
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3128_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	desc->ops = &rk3128_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3288_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	u32 val;
++
++	node = of_parse_phandle(np, "rockchip,pmu", 0);
++	if (node) {
++		data->regmap_pmu = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_pmu))
++			return PTR_ERR(data->regmap_pmu);
++	}
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	regmap_read(data->regmap_pmu, RK3288_PMU_SYS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = READ_CH_INFO(val);
++
++	if (data->dram_type == DDR3)
++		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
++			     RK3288_DDR3_SEL);
++	else
++		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
++			     RK3288_LPDDR_SEL);
++
++	desc->ops = &rk3288_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3368_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device *dev = &pdev->dev;
++
++	if (!dev->parent || !dev->parent->of_node)
++		return -EINVAL;
++
++	data->regmap_grf = syscon_node_to_regmap(dev->parent->of_node);
++	if (IS_ERR(data->regmap_grf))
++		return PTR_ERR(data->regmap_grf);
++
++	desc->ops = &rk3368_dfi_ops;
++
++	return 0;
++}
++
++static __init int rockchip_dfi_init(struct platform_device *pdev,
++				    struct rockchip_dfi *data,
++				    struct devfreq_event_desc *desc)
+ {
+ 	struct device *dev = &pdev->dev;
+-	struct rockchip_dfi *data;
+ 	struct resource *res;
+-	struct devfreq_event_desc *desc;
+ 	struct device_node *np = pdev->dev.of_node, *node;
+-
+-	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
+-	if (!data)
+-		return -ENOMEM;
++	u32 val;
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	data->regs = devm_ioremap_resource(&pdev->dev, res);
+@@ -203,21 +583,97 @@ static int rockchip_dfi_probe(struct platform_device *pdev)
+ 		if (IS_ERR(data->regmap_pmu))
+ 			return PTR_ERR(data->regmap_pmu);
+ 	}
+-	data->dev = dev;
++
++	regmap_read(data->regmap_pmu, PMUGRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = READ_CH_INFO(val);
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3328_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	struct resource *res;
++	u32 val;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs))
++		return PTR_ERR(data->regs);
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	regmap_read(data->regmap_grf, RK3328_GRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = 1;
++	data->clk = NULL;
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static const struct of_device_id rockchip_dfi_id_match[] = {
++	{ .compatible = "rockchip,px30-dfi", .data = px30_dfi_init },
++	{ .compatible = "rockchip,rk1808-dfi", .data = px30_dfi_init },
++	{ .compatible = "rockchip,rk3128-dfi", .data = rk3128_dfi_init },
++	{ .compatible = "rockchip,rk3288-dfi", .data = rk3288_dfi_init },
++	{ .compatible = "rockchip,rk3328-dfi", .data = rk3328_dfi_init },
++	{ .compatible = "rockchip,rk3368-dfi", .data = rk3368_dfi_init },
++	{ .compatible = "rockchip,rk3399-dfi", .data = rockchip_dfi_init },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
++
++static int rockchip_dfi_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct rockchip_dfi *data;
++	struct devfreq_event_desc *desc;
++	struct device_node *np = pdev->dev.of_node;
++	const struct of_device_id *match;
++	int (*init)(struct platform_device *pdev, struct rockchip_dfi *data,
++		    struct devfreq_event_desc *desc);
++
++	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
+ 
+ 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+ 	if (!desc)
+ 		return -ENOMEM;
+ 
+-	desc->ops = &rockchip_dfi_ops;
++	match = of_match_node(rockchip_dfi_id_match, pdev->dev.of_node);
++	if (match) {
++		init = match->data;
++		if (init) {
++			if (init(pdev, data, desc))
++				return -EINVAL;
++		} else {
++			return 0;
++		}
++	} else {
++		return 0;
++	}
++
+ 	desc->driver_data = data;
+ 	desc->name = np->name;
+ 	data->desc = desc;
++	data->dev = dev;
+ 
+-	data->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);
++	data->edev = devm_devfreq_event_add_edev(dev, desc);
+ 	if (IS_ERR(data->edev)) {
+-		dev_err(&pdev->dev,
+-			"failed to add devfreq-event device\n");
++		dev_err(dev, "failed to add devfreq-event device\n");
+ 		return PTR_ERR(data->edev);
+ 	}
-- 
2.17.1

