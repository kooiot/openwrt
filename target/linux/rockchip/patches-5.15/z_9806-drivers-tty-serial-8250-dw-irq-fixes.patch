--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -33,6 +33,7 @@
 
 /* Offsets for the DesignWare specific registers */
 #define DW_UART_USR	0x1f /* UART Status Register */
+#define DW_UART_RFL	0x21 /* UART Receive Fifo Level Register */
 
 /* DesignWare specific register fields */
 #define DW_UART_MCR_SIRE		BIT(6)
@@ -238,10 +239,12 @@
 
 static int dw8250_handle_irq(struct uart_port *p)
 {
+#ifndef CONFIG_ARCH_ROCKCHIP
 	struct uart_8250_port *up = up_to_u8250p(p);
+#endif
 	struct dw8250_data *d = to_dw8250_data(p->private_data);
 	unsigned int iir = p->serial_in(p, UART_IIR);
-	unsigned int status;
+	unsigned int status, usr, rfl;
 	unsigned long flags;
 
 	/*
@@ -254,6 +257,7 @@
 	 * This problem has only been observed so far when not in DMA mode
 	 * so we limit the workaround only to non-DMA mode.
 	 */
+#ifndef CONFIG_ARCH_ROCKCHIP
 	if (!up->dma && ((iir & 0x3f) == UART_IIR_RX_TIMEOUT)) {
 		spin_lock_irqsave(&p->lock, flags);
 		status = p->serial_in(p, UART_LSR);
@@ -263,6 +267,18 @@
 
 		spin_unlock_irqrestore(&p->lock, flags);
 	}
+#else
+	if ((iir & 0x3f) == UART_IIR_RX_TIMEOUT) {
+		spin_lock_irqsave(&p->lock, flags);
+		usr = p->serial_in(p, d->usr_reg);
+		status = p->serial_in(p, UART_LSR);
+		rfl = p->serial_in(p, DW_UART_RFL);
+		if (!(status & (UART_LSR_DR | UART_LSR_BI)) && !(usr & 0x1) && (rfl == 0))
+			(void) p->serial_in(p, UART_RX);
+
+		spin_unlock_irqrestore(&p->lock, flags);
+	}
+#endif
 
 	if (serial8250_handle_irq(p, iir))
 		return 1;
